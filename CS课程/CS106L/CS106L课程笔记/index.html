
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/">
      
      
        <link rel="next" href="../CS106L-Midquarter-Review/">
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.0, mkdocs-material-9.5.21">
    
    
      
        <title>CS106L课程笔记 - 罹魂梦蝶の笔记空间</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.66ac8b77.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Hiragino+Sans+GB:300,300i,400,400i,700,700i%7CRoboto+Mono在·:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Hiragino Sans GB";--md-code-font:"Roboto Mono在·"}</style>
      
    
    
      <link rel="stylesheet" href="../../../from_oi_wiki/css/extra.css?v=13">
    
      <link rel="stylesheet" href="../../../css/status.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="black" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#lec1-welcome-to-cs-106l" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="罹魂梦蝶の笔记空间" class="md-header__button md-logo" aria-label="罹魂梦蝶の笔记空间" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            罹魂梦蝶の笔记空间
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              CS106L课程笔记
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../.." class="md-tabs__link">
          
  
    
  
  主页

        </a>
      </li>
    
  

      
        
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../../" class="md-tabs__link">
          
  
    
  
  CS 课程

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" class="md-tabs__link">
          
  
    
  
  论文阅读

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../%E6%9D%82%E9%A1%B9/" class="md-tabs__link">
          
  
    
  
  杂项

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="罹魂梦蝶の笔记空间" class="md-nav__button md-logo" aria-label="罹魂梦蝶の笔记空间" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    罹魂梦蝶の笔记空间
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_1" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../.." class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    主页
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_1" id="__nav_1_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_1">
            <span class="md-nav__icon md-icon"></span>
            主页
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../about/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    关于我
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
      
        
        
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" checked>
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    CS 课程
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_2" id="__nav_2_label" tabindex="">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            CS 课程
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    
    
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2" >
        
          
          <label class="md-nav__link" for="__nav_2_2" id="__nav_2_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    计算机视觉导论
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2">
            <span class="md-nav__icon md-icon"></span>
            计算机视觉导论
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AF%BC%E8%AE%BA/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    课程笔记
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
    
  
  
  
    
    
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_3" checked>
        
          
          <label class="md-nav__link" for="__nav_2_3" id="__nav_2_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    CS106L
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_3_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2_3">
            <span class="md-nav__icon md-icon"></span>
            CS106L
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    课程笔记
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    课程笔记
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#why-c-is-important" class="md-nav__link">
    <span class="md-ellipsis">
      Why C++ is important
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#what-is-c" class="md-nav__link">
    <span class="md-ellipsis">
      What is C++
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../CS106L-Midquarter-Review/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    期中复习
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../../%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    论文阅读
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_3" id="__nav_3_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            论文阅读
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    
    
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_2" >
        
          
          <label class="md-nav__link" for="__nav_3_2" id="__nav_3_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    3D Reconstruction
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_2">
            <span class="md-nav__icon md-icon"></span>
            3D Reconstruction
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/reconstruction/NeRF/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    NeRF
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/reconstruction/Depth-Gaussian/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Depth-Gaussian
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_3" >
        
          
          <label class="md-nav__link" for="__nav_3_3" id="__nav_3_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Human Motion Generation
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_3">
            <span class="md-nav__icon md-icon"></span>
            Human Motion Generation
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/motion/Generating%20Continual%20Human%20Motion%20in%20Diverse%203D%20Scenes/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Generating Continual Human Motion in Diverse 3D Scenes
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/motion/Generating%20Human%20Interaction%20Motions%20in%20Scenes%20with%20Text%20Control/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    TeSMo
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/motion/Generating%20Human%20Motion%20in%203D%20Scenes%20from%20Text%20Descriptions/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Generating Human Motion in 3D Scenes from Text Descriptions
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/motion/GPT-Connect/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    GPT-Connect
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/motion/Human%20Motion%20Generation%20A%20Survey/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Human Motion Generation Survey
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/motion/STMC/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    STMC
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../../%E6%9D%82%E9%A1%B9/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    杂项
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_4" id="__nav_4_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            杂项
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E6%9D%82%E9%A1%B9/11-25%E7%AD%BE%E5%88%B0%E6%8E%A8/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    AI绘图
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E6%9D%82%E9%A1%B9/%E4%B8%93%E4%B8%9A%E5%88%86%E6%B5%81%E5%86%85%E8%AE%AD/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    本科专业分流
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#why-c-is-important" class="md-nav__link">
    <span class="md-ellipsis">
      Why C++ is important
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#what-is-c" class="md-nav__link">
    <span class="md-ellipsis">
      What is C++
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p>Stanford CS106L: Standard C++ Programming课程笔记。</p>
<!--more-->

<blockquote>
<p>引言：<em>CS106B/X</em> 和 <em>CS106L</em> 是配套课程，学习完前一个再学习 <em>CS106L</em> 才是正确的路径。但是浙江大学的《数据结构基础》课程已经包括了 <em>CS106B</em> 中除 <em>C++ Class</em> 和 <em>Huffman Coding</em> 之外的其他内容，所以对于 <em>CS106B</em> 的内容仅做简单补充。</p>
<p>此笔记基于 <em>CS 106L, Fall '21</em></p>
</blockquote>
<h1 id="lec1-welcome-to-cs-106l">Lec1 Welcome to CS 106L!<a class="headerlink" href="#lec1-welcome-to-cs-106l" title="Permanent link">&para;</a></h1>
<h2 id="why-c-is-important">Why C++ is important<a class="headerlink" href="#why-c-is-important" title="Permanent link">&para;</a></h2>
<h2 id="what-is-c">What is C++<a class="headerlink" href="#what-is-c" title="Permanent link">&para;</a></h2>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Hello World!&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;stdio.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;stdlib.h&quot;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="k">asm</span><span class="p">(</span><span class="s">&quot;sub $0x20,%rsp</span><span class="se">\n\t</span><span class="s">&quot;</span><span class="w"> </span><span class="c1">// assembly code!</span>
<span class="w">         </span><span class="s">&quot;movabs $0x77202c6f6c6c6548,%rax</span><span class="se">\n\t</span><span class="s">&quot;</span>
<span class="w">         </span><span class="s">&quot;mov %rax,(%rsp)</span><span class="se">\n\t</span><span class="s">&quot;</span>
<span class="w">         </span><span class="s">&quot;movl $0x646c726f, 0x8(%rsp)</span><span class="se">\n\t</span><span class="s">&quot;</span>
<span class="w">         </span><span class="s">&quot;movw $0x21, 0xc(%rsp)</span><span class="se">\n\t</span><span class="s">&quot;</span>
<span class="w">         </span><span class="s">&quot;movb $0x0,0xd(%rsp)</span><span class="se">\n\t</span><span class="s">&quot;</span>
<span class="w">         </span><span class="s">&quot;leaq (%rsp),%rax</span><span class="se">\n\t</span><span class="s">&quot;</span>
<span class="w">         </span><span class="s">&quot;mov %rax,%rdi</span><span class="se">\n\t</span><span class="s">&quot;</span>
<span class="w">         </span><span class="s">&quot;call __Z6myputsPc</span><span class="se">\n\t</span><span class="s">&quot;</span>
<span class="w">         </span><span class="s">&quot;add $0x20, %rsp</span><span class="se">\n\t</span><span class="s">&quot;</span>
<span class="w">     </span><span class="p">);</span>
<span class="w">     </span><span class="k">return</span><span class="w"> </span><span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h1 id="lec2-types-and-structs">Lec2 Types and Structs<a class="headerlink" href="#lec2-types-and-structs" title="Permanent link">&para;</a></h1>
<blockquote>
<p>Types make things better...and sometimes harder...but still better</p>
</blockquote>
<h2 id="types">Types<a class="headerlink" href="#types" title="Permanent link">&para;</a></h2>
<h3 id="fundamental-types">Fundamental Types<a class="headerlink" href="#fundamental-types" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="c1">//32 bits</span>
<span class="kt">char</span><span class="w"> </span><span class="n">ch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;F&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">//8 bits (usually)</span>
<span class="kt">float</span><span class="w"> </span><span class="n">decimalVal1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">5.0</span><span class="p">;</span><span class="w"> </span><span class="c1">//32 bits (usually)</span>
<span class="kt">double</span><span class="w"> </span><span class="n">decimalVal2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">5.0</span><span class="p">;</span><span class="w"> </span><span class="c1">//64 bits (usually)</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">bVal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"> </span><span class="c1">//1 bit</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Frankie&quot;</span><span class="p">;</span>
</code></pre></div>
<p>​   C++ is a statically typed language: everything  with a name (variables,  functions, etc) is given a  type before runtime</p>
<p>​   static typing helps us to  prevent errors before our  code runs</p>
<h3 id="static-types--function">Static Types + Function<a class="headerlink" href="#static-types--function" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">int</span>
<span class="n">string</span><span class="w"> </span><span class="n">echo</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">phrase</span><span class="p">);</span>
<span class="n">string</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">string</span>
<span class="n">string</span><span class="w"> </span><span class="n">helloworld</span><span class="p">();</span>
<span class="kt">void</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">string</span>
<span class="kt">double</span><span class="w"> </span><span class="n">divide</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">double</span>
</code></pre></div>
<h3 id="overloading">Overloading<a class="headerlink" href="#overloading" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">half</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">divisor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// (1)</span>
<span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">divisor</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">double</span><span class="w"> </span><span class="nf">half</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// (2)</span>
<span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">half</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="c1">// uses version (1), returns 1</span>
<span class="n">half</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="c1">// uses version (1), returns 1</span>
<span class="n">half</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span><span class="w"> </span><span class="c1">// uses version (2), returns 1.5</span>
</code></pre></div>
<h2 id="intro-to-structs">Intro to structs<a class="headerlink" href="#intro-to-structs" title="Permanent link">&para;</a></h2>
<blockquote>
<p>struct: a group of named variables each with their own type. A way to bundle different types together</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">Student</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">;</span><span class="w"> </span><span class="c1">// these are called fields</span>
<span class="w">    </span><span class="n">string</span><span class="w"> </span><span class="n">state</span><span class="p">;</span><span class="w"> </span><span class="c1">// separate these by semicolons</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">age</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">Student</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="n">s</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Frankie&quot;</span><span class="p">;</span><span class="w"> </span>
<span class="n">s</span><span class="p">.</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;MN&quot;</span><span class="p">;</span>
<span class="n">s</span><span class="p">.</span><span class="n">age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">21</span><span class="p">;</span><span class="w"> </span><span class="c1">// use . to access fields</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">printStudentInfo</span><span class="p">(</span><span class="n">Student</span><span class="w"> </span><span class="n">student</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; from &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">state</span><span class="p">;</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; (&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">age</span><span class="w"> </span><span class="s">&quot;)&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">Student</span><span class="w"> </span><span class="nf">randomStudentFrom</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">state</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Student</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="w">    </span><span class="n">s</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Frankie&quot;</span><span class="p">;</span><span class="c1">//random = always Frankie</span>
<span class="w">    </span><span class="n">s</span><span class="p">.</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">state</span><span class="p">;</span>
<span class="w">    </span><span class="n">s</span><span class="p">.</span><span class="n">age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
<span class="w"> </span><span class="n">Student</span><span class="w"> </span><span class="n">foundStudent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">randomStudentFrom</span><span class="p">(</span><span class="s">&quot;MN&quot;</span><span class="p">);</span>
<span class="w"> </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">foundStudent</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// Frankie</span>
</code></pre></div>
<blockquote>
<p>std::pair: An STL  built-in struct with two fields of any type</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">numSuffix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;st&quot;</span><span class="p">};</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">numSuffix</span><span class="p">.</span><span class="n">first</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">numSuffix</span><span class="p">.</span><span class="n">second</span><span class="p">;</span><span class="w"> </span>
<span class="c1">//prints 1st</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Pair</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">fill_in_type</span><span class="w"> </span><span class="n">first</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="n">fill_in_type</span><span class="w"> </span><span class="n">second</span><span class="p">;</span><span class="w"> </span>
<span class="p">};</span>
<span class="c1">//pair in functions</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">Student</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lookupStudent</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Student</span><span class="w"> </span><span class="n">blank</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">found</span><span class="p">(</span><span class="n">name</span><span class="p">))</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="n">blank</span><span class="p">);</span>
<span class="w">    </span><span class="n">Student</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getStudentWithName</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">Student</span><span class="o">&gt;</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lookupStudent</span><span class="p">(</span><span class="err">“</span><span class="n">Keith</span><span class="err">”</span><span class="p">);</span>
</code></pre></div>
<blockquote>
<p>auto: Keyword used in lieu  of type when declaring a  variable, tells the compiler  to deduce the type.</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="c1">//It means that the type is  deduced by the compiler. </span>
<span class="k">auto</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">4.3</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">‘</span><span class="n">X</span><span class="err">’</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">“</span><span class="n">Hello</span><span class="err">”</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="err">“</span><span class="n">Hello</span><span class="err">”</span><span class="p">);</span>
</code></pre></div>
<h2 id="sneak-peek-at-streams">Sneak peek at streams<a class="headerlink" href="#sneak-peek-at-streams" title="Permanent link">&para;</a></h2>
<blockquote>
<p>stream: an abstraction for input/output. Streams convert between data and the string representation of data.</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// prints 5 </span>
<span class="c1">// use a stream to print any primitive type!</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Frankie&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span>
<span class="c1">// Mix types!</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Frankie is &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">21</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="c1">// structs?</span>
<span class="n">Student</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="s">&quot;Frankie&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;MN&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">21</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">age</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</code></pre></div>
<h2 id="recap">Recap<a class="headerlink" href="#recap" title="Permanent link">&para;</a></h2>
<ul>
<li>Everything with a name in your program has a type</li>
<li>Strong type systems prevent errors before your code runs!</li>
<li>Structs are a way to bundle a bunch of variables of many types </li>
<li>std::pair is a type of struct that had been defined for you and is in the STL</li>
<li>So you access it through the std:: namespace (std::pair) </li>
<li>auto is a keyword that tells the compiler to deduce the type of a variable, it should be used when the type is obvious or very  cumbersome to write out</li>
</ul>
<h1 id="lec3-initialization--references">Lec3 Initialization &amp; References<a class="headerlink" href="#lec3-initialization--references" title="Permanent link">&para;</a></h1>
<h2 id="initialization">Initialization<a class="headerlink" href="#initialization" title="Permanent link">&para;</a></h2>
<blockquote>
<p>Initialization: How we provide initial values to variables</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="c1">// Recall: Two ways to initialize a struct</span>
<span class="n">Student</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="n">s</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Frankie&quot;</span><span class="p">;</span><span class="w"> </span>
<span class="n">s</span><span class="p">.</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;MN&quot;</span><span class="p">;</span>
<span class="n">s</span><span class="p">.</span><span class="n">age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">21</span><span class="p">;</span><span class="w"> </span>
<span class="c1">//is the same as ...</span>
<span class="n">Student</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="s">&quot;Frankie&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;MN&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">21</span><span class="p">};</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="c1">//Multiple ways to initialize a pair</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">numSuffix1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;st&quot;</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">numSuffix2</span><span class="p">;</span>
<span class="n">numSuffix2</span><span class="p">.</span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="n">numSuffix2</span><span class="p">.</span><span class="n">second</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;nd&quot;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">numSuffix2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;rd&quot;</span><span class="p">);</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="c1">//Initialization of vectors</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec1</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span><span class="w"> </span>
<span class="c1">// makes {5, 5, 5}, not {3, 5}!</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec2</span><span class="p">;</span>
<span class="n">vec2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>
<span class="c1">// initialize vec2 to {3, 5} after its declared</span>
</code></pre></div>
<blockquote>
<p>Uniform initialization: curly bracket initialization.  Available for all types,  immediate initialization on declaration(统一初始化：声明时用花括号定义)</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">numSuffix1</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;st&quot;</span><span class="p">};</span>
<span class="n">Student</span><span class="w"> </span><span class="n">s</span><span class="p">{</span><span class="s">&quot;Frankie&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;MN&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">21</span><span class="p">};</span>
<span class="c1">// less common/nice for primitive types, but possible!</span>
<span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">{</span><span class="mi">5</span><span class="p">};</span>
<span class="n">string</span><span class="w"> </span><span class="n">f</span><span class="p">{</span><span class="s">&quot;Frankie&quot;</span><span class="p">};</span>
<span class="c1">//Careful with Vector initialization!</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec1</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span><span class="w"> </span>
<span class="c1">// makes {5, 5, 5}, not {3, 5}!</span>
<span class="c1">//uses a std::initializer_list (more later)</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec2</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>
<span class="c1">// makes {3, 5}</span>

<span class="c1">//TLDR: use uniform  initialization to initialize every  field of your non-primitive  typed variables - but be  careful not to use vec(n, k)!</span>
</code></pre></div>
<blockquote>
<p>auto:  use it to reduce long type names</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">quadratic</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>
<span class="c1">//It can be write as below</span>
<span class="k">auto</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">quadratic</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>
</code></pre></div>
<p><strong>Don’t overuse auto!</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1">//A better way to use quadratic</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="k">auto</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="w">     </span><span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="w">     </span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">found</span><span class="p">,</span><span class="w"> </span><span class="n">solutions</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">quadratic</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>
<span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">found</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">         </span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">x1</span><span class="p">,</span><span class="w"> </span><span class="n">x2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">solutions</span><span class="p">;</span>
<span class="w">         </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">x1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="err">“</span><span class="w"> </span><span class="err">”</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">x2</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">     </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">         </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="err">“</span><span class="n">No</span><span class="w"> </span><span class="n">solutions</span><span class="w"> </span><span class="n">found</span><span class="o">!</span><span class="err">”</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">     </span><span class="p">}</span>
<span class="p">}</span>
<span class="c1">//This is better is because it’s semantically clearer: variables have clear names</span>
</code></pre></div>
<h2 id="references">References<a class="headerlink" href="#references" title="Permanent link">&para;</a></h2>
<blockquote>
<p>Reference: An alias  (another name) for a named variable</p>
</blockquote>
<p><strong>References in 106B</strong></p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">changeX</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">x</span><span class="p">){</span><span class="w"> </span><span class="c1">//changes to x will persist</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">keepX</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">){</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
<span class="n">changeX</span><span class="p">(</span><span class="n">a</span><span class="p">);</span><span class="w"> </span><span class="c1">//a becomes a reference to x</span>
<span class="n">keepX</span><span class="p">(</span><span class="n">b</span><span class="p">);</span><span class="w"> </span><span class="c1">//b becomes a copy of x</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">//0</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">//100</span>
</code></pre></div>
<p><strong>References in 106L: References to variables</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">original</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">};</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">copy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">original</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">original</span><span class="p">;</span>
<span class="n">original</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="n">copy</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="n">ref</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">original</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// {1, 2, 3, 5}</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">copy</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// {1, 2, 4}</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// {1, 2, 3, 5}</span>
<span class="c1">//“=” automatically makes a copy! Must use &amp; to avoid this.</span>
</code></pre></div>
<p><strong>Reference-copy bug</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1">//bug</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">shift</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">nums</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">num1</span><span class="p">,</span><span class="w"> </span><span class="n">num2</span><span class="p">]</span><span class="o">:</span><span class="w"> </span><span class="n">nums</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">num1</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="n">num2</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="c1">//fixed</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">shift</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">nums</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="p">[</span><span class="n">num1</span><span class="p">,</span><span class="w"> </span><span class="n">num2</span><span class="p">]</span><span class="o">:</span><span class="w"> </span><span class="n">nums</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">num1</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="n">num2</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<blockquote>
<ul>
<li>l-values</li>
<li>l-values can appear on the left or  right of an =</li>
<li><code>x</code> is an l-value</li>
<li>l-values have names</li>
<li>l-values are not temporary</li>
<li>r-values</li>
<li>r-values can ONLY appear on the  right of an =</li>
<li><code>3</code> is an r-value</li>
<li>r-values don’t have names</li>
<li>r-values are temporary</li>
</ul>
</blockquote>
<p><strong>The classic reference-rvalue error</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1">//可以取地址的，有名字的，非临时的就是左值；不能取地址的，没有名字的，临时的就是右值；</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">shift</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">nums</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="p">[</span><span class="n">num1</span><span class="p">,</span><span class="w"> </span><span class="n">num2</span><span class="p">]</span><span class="o">:</span><span class="w"> </span><span class="n">nums</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">num1</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="n">num2</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="n">shift</span><span class="p">({{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">}});</span><span class="w"> </span>
<span class="c1">// {{1, 1}} is an rvalue, it can’t be referenced</span>

<span class="c1">//fixed</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">shift</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">nums</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="p">[</span><span class="n">num1</span><span class="p">,</span><span class="w"> </span><span class="n">num2</span><span class="p">]</span><span class="o">:</span><span class="w"> </span><span class="n">nums</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">num1</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="n">num2</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="k">auto</span><span class="w"> </span><span class="n">my_nums</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">}};</span>
<span class="n">shift</span><span class="p">(</span><span class="n">my_nums</span><span class="p">);</span>
</code></pre></div>
<h2 id="bonus-const-and-const-references">BONUS: Const and Const References<a class="headerlink" href="#bonus-const-and-const-references" title="Permanent link">&para;</a></h2>
<blockquote>
<p>const indicates a variable can’t be modified!</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">};</span>
<span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">c_vec</span><span class="p">{</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">};</span><span class="w"> </span><span class="c1">// a const variable</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="p">;</span><span class="w"> </span><span class="c1">// a regular reference</span>
<span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">c_ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="p">;</span><span class="w"> </span><span class="c1">// a const reference, 注意前面也要加上 const</span>

<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="w"> </span><span class="c1">// OKAY</span>
<span class="n">c_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="w"> </span><span class="c1">// BAD - const</span>
<span class="n">ref</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="w"> </span><span class="c1">// OKAY</span>
<span class="n">c_ref</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="w"> </span><span class="c1">// BAD - const</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">c_vec</span><span class="p">{</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">};</span><span class="w"> </span><span class="c1">// a const variable</span>
<span class="c1">// BAD - can&#39;t declare non-const ref to const vector</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">bad_ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c_vec</span><span class="p">;</span>
<span class="c1">// fixed</span>
<span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">bad_ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c_vec</span><span class="p">;</span>
<span class="c1">// BAD - Can&#39;t declare a non-const reference as equal to a const reference!</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c_ref</span><span class="p">;</span>
</code></pre></div>
<p><strong>const &amp; subtleties</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">};</span>
<span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">c_vec</span><span class="p">{</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">c_ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">copy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c_ref</span><span class="p">;</span><span class="w"> </span><span class="c1">// a non-const copy</span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">copy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c_ref</span><span class="p">;</span><span class="w"> </span><span class="c1">// a const copy</span>
<span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ref</span><span class="p">;</span><span class="w"> </span><span class="c1">// a non-const reference</span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">c_aref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ref</span><span class="p">;</span><span class="w"> </span><span class="c1">// a const reference</span>
</code></pre></div>
<p>​   Remember: C++, by default, makes copies when we  do variable assignment! We need to use &amp; if we  need references instead.</p>
<h2 id="recap_1">Recap<a class="headerlink" href="#recap_1" title="Permanent link">&para;</a></h2>
<ul>
<li>Use input streams to get information</li>
<li>Use structs to bundle information</li>
<li>Use uniform initialization wherever possible</li>
<li>Use references to have multiple aliases to the same thing</li>
<li>Use const references to avoid making copies whenever possible</li>
</ul>
<h1 id="lec4-streams">Lec4 Streams<a class="headerlink" href="#lec4-streams" title="Permanent link">&para;</a></h1>
<blockquote>
<p>stream: an abstraction for input/output. Streams convert between data and the string representation of data.</p>
</blockquote>
<h2 id="input-streams">Input streams<a class="headerlink" href="#input-streams" title="Permanent link">&para;</a></h2>
<blockquote>
<p>std::cin is an input stream. It has type std::istream</p>
</blockquote>
<ul>
<li>Have type std::istream</li>
<li>Can only receive strings using the <code>&gt;&gt;</code> operator</li>
<li>Receives a string from the stream and converts it to data </li>
<li>std::cin is the input stream that gets input from the console</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="n">string</span><span class="w"> </span><span class="n">str</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">str</span><span class="p">;</span>
<span class="c1">//reads exactly one int then 1 string from console</span>
</code></pre></div>
<ul>
<li>First call to std::cin &gt;&gt; creates a command line prompt  that allows the user to type until they hit enter</li>
<li><strong>Each <code>&gt;&gt;</code> ONLY reads until the next whitespace</strong></li>
<li><strong>Whitespace = tab, space, newline</strong></li>
<li>Everything after the first whitespace gets saved and used the  next time std::cin &gt;&gt; is called</li>
<li>If there is nothing waiting in the buffer, std::cin &gt;&gt; creates a new command line prompt</li>
<li>Whitespace is eaten: it won’t show up in output</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="n">string</span><span class="w"> </span><span class="n">str</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">str</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="c1">//what happens if input is &quot;blah blah&quot;?</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">str</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="c1">//once an error is detected, the input stream’s</span>
<span class="c1">//fail bit is set, and it will no longer accept </span>
<span class="c1">//input</span>
</code></pre></div>
<p><strong>To read a whole line, use  std::getline(istream&amp; stream, string&amp; line);</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">line</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">cin</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">);</span><span class="w"> </span><span class="c1">//now line has changed!</span>
<span class="c1">//say the user entered “Hello World 42!” </span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span>
<span class="c1">//should print out“Hello World 42!”</span>
</code></pre></div>
<ul>
<li><code>&gt;&gt;</code> reads up to the next whitespace character and does not go past that whitespace character.</li>
<li><code>getline</code> reads up to the next delimiter (by default, ‘\n’), and does go past that delimiter.</li>
</ul>
<h2 id="output-streams">Output streams<a class="headerlink" href="#output-streams" title="Permanent link">&para;</a></h2>
<blockquote>
<p>std::cout is an output  stream. It has type std::ostream</p>
</blockquote>
<ul>
<li>Can only send data using the &lt;&lt; operator</li>
<li>Converts any type into string and sends it to the stream</li>
<li>std::cout is the output stream that goes to the console</li>
</ul>
<h2 id="file-streams">File streams<a class="headerlink" href="#file-streams" title="Permanent link">&para;</a></h2>
<h3 id="input-file-streams">Input File Streams<a class="headerlink" href="#input-file-streams" title="Permanent link">&para;</a></h3>
<ul>
<li>Have type std::ifstream</li>
<li>Only send data using the &gt;&gt; operator</li>
<li>Receives strings from a file and converts it to data of any type</li>
<li>Must initialize your own ifstream object linked to your file</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">ifstream</span><span class="w"> </span><span class="nf">in</span><span class="p">(</span><span class="err">“</span><span class="n">out</span><span class="p">.</span><span class="n">txt</span><span class="err">”</span><span class="p">);</span>
<span class="c1">// in is now an ifstream that reads from out.txt</span>
<span class="n">string</span><span class="w"> </span><span class="n">str</span><span class="p">;</span>
<span class="n">in</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">str</span><span class="p">;</span><span class="w"> </span><span class="c1">// first word in out.txt goes into str</span>
</code></pre></div>
<h3 id="output-file-streams">Output File Streams<a class="headerlink" href="#output-file-streams" title="Permanent link">&para;</a></h3>
<ul>
<li>Have type std::ofstream</li>
<li>Only send data using the &lt;&lt; operator</li>
<li>Converts data of any type into a string and sends it to the file stream</li>
<li>Must initialize your own ofstream object linked to your file</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="w"> </span><span class="nf">out</span><span class="p">(</span><span class="err">“</span><span class="n">out</span><span class="p">.</span><span class="n">txt</span><span class="err">”</span><span class="p">);</span>
<span class="c1">// out is now an ofstream that outputs to out.txt</span>
<span class="n">out</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// out.txt contains 5</span>
</code></pre></div>
<h2 id="string-streams">string streams<a class="headerlink" href="#string-streams" title="Permanent link">&para;</a></h2>
<ul>
<li>Input stream: std::istringstream</li>
<li>Give any data type to the istringstream, it’ll store it as a  string!</li>
<li>Output stream: std::ostringstream</li>
<li>Make an ostringstream out of a string, read from it  word/type by word/type</li>
<li>The same as the other i/ostreams you’ve seen!</li>
</ul>
<h3 id="ostringstreams">ostringstreams<a class="headerlink" href="#ostringstreams" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="n">string</span><span class="w"> </span><span class="nf">judgementCall</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">age</span><span class="p">,</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">lovesCpp</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span><span class="w"> </span><span class="n">formatter</span><span class="p">;</span>
<span class="w">    </span><span class="n">formatter</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="s">&quot;, age &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">age</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">lovesCpp</span><span class="p">)</span><span class="w"> </span><span class="n">formatter</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, rocks.&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="n">formatter</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; could be better&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">formatter</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="istringstreams">istringstreams<a class="headerlink" href="#istringstreams" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="n">Student</span><span class="w"> </span><span class="nf">reverseJudgementCall</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">judgement</span><span class="p">){</span><span class="w"> </span>
<span class="w">    </span><span class="c1">//input: “Frankie age 22, rocks”</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">istringstream</span><span class="w"> </span><span class="n">converter</span><span class="p">;</span>
<span class="w">    </span><span class="n">string</span><span class="w"> </span><span class="n">fluff</span><span class="p">;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">age</span><span class="p">;</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">lovesCpp</span><span class="p">;</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="n">converter</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="n">converter</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">fluff</span><span class="p">;</span>
<span class="w">    </span><span class="n">converter</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">age</span><span class="p">;</span>
<span class="w">    </span><span class="n">converter</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">fluff</span><span class="p">;</span>
<span class="w">    </span><span class="n">string</span><span class="w"> </span><span class="n">cool</span><span class="p">;</span>
<span class="w">    </span><span class="n">converter</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">cool</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">cool</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;rocks&quot;</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">Student</span><span class="p">{</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">age</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;bliss&quot;</span><span class="p">};</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">Student</span><span class="p">{</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">age</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;misery&quot;</span><span class="p">};</span>
<span class="p">}</span><span class="c1">// returns: {“Frankie”, 22, “bliss”}</span>
</code></pre></div>
<h2 id="recap_2">Recap<a class="headerlink" href="#recap_2" title="Permanent link">&para;</a></h2>
<ul>
<li>Streams convert between data of any type and the string  representation of that data.</li>
<li>Streams have an endpoint: console for cin/cout, files for i/o fstreams,  string variables for i/o streams where they read in a string from or  output a string to. </li>
<li>To send data (in string form) to a stream, use stream_name &lt;&lt;  data.</li>
<li>To extract data from a stream, use stream_name &gt;&gt; data, and the stream will try to convert a string to whatever type data is.</li>
</ul>
<h1 id="lec5-containers">Lec5 Containers<a class="headerlink" href="#lec5-containers" title="Permanent link">&para;</a></h1>
<blockquote>
<p>What's in the STL:</p>
<ul>
<li>Containers</li>
<li>Iterators</li>
<li>Functions</li>
<li>Algorithms</li>
</ul>
</blockquote>
<h2 id="types-of-containers">Types of containers<a class="headerlink" href="#types-of-containers" title="Permanent link">&para;</a></h2>
<p>All containers can hold almost all elements</p>
<pre class="mermaid"><code>graph TB
A[Sequence Containers]--&gt;B[Simple]
A--&gt;C[Adaptors]
B--&gt;d[vector]
B--&gt;e[deque]
B--&gt;f[list]
B--&gt;q[tuple]
C--&gt;p[stack]
C--&gt;o[queue]
C--&gt;m[priority_queue]</code></pre>
<pre class="mermaid"><code>graph TB
A[Associative Containers]--&gt;B[Ordered]
A--&gt;C[Unordered]
B--&gt;set
B--&gt;map
C--&gt;unordered_set
C--&gt;unordered_map</code></pre>
<h2 id="sequence-containers">Sequence Containers<a class="headerlink" href="#sequence-containers" title="Permanent link">&para;</a></h2>
<h3 id="vector">vector<a class="headerlink" href="#vector" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="cpf">&lt;vector&gt;</span>
<span class="c1">//construct</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">intArr</span><span class="p">;</span><span class="c1">//Create a new, empty vector</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec</span><span class="p">(</span><span class="n">n</span><span class="p">);</span><span class="c1">//Create a vector with n copies of 0 </span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">);</span><span class="c1">//Create a vector with n copies of a value k</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">strArr</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">myStruct</span><span class="o">&gt;</span><span class="w"> </span><span class="n">structArr</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">vecArr</span><span class="p">;</span><span class="c1">//二维数组</span>

<span class="c1">//use</span>
<span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="c1">//Get the element at index i (does not bounds check)</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">k</span><span class="p">);</span><span class="c1">//Add a value k to the end of a vector</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="c1">//Loop through vector by index i</span>
<span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k</span><span class="p">;</span><span class="c1">//Replace the element at index i(does not bounds check)</span>
<span class="n">vec</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span><span class="c1">//Remove all elements of a vector</span>
<span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="c1">//Check size of vector </span>
<span class="n">vec</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span><span class="c1">//删除末尾</span>
<span class="n">vec</span><span class="p">.</span><span class="n">capacity</span><span class="p">();</span><span class="c1">//给vector分配的空间大小</span>
<span class="n">vec</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span><span class="c1">//判断是否为空</span>
<span class="n">vec</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="c1">//位置为2处元素引用</span>
<span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="c1">//头指针</span>
<span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="c1">//尾指针</span>
</code></pre></div>
<p><a href="https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html">菜鸟教程</a></p>
<h3 id="array">array<a class="headerlink" href="#array" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="cpf">&lt;array&gt;</span>
<span class="c1">//construct</span>
<span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="o">&gt;</span><span class="p">;</span><span class="c1">//4*3的string数组</span>
<span class="c1">//访问</span>
<span class="n">arr</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="n">at</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="c1">//二维数组中访问</span>
</code></pre></div>
<h3 id="deque">deque<a class="headerlink" href="#deque" title="Permanent link">&para;</a></h3>
<p>​   <code>deque</code>支持<code>vector</code>的所有操作，并且支持快速<code>push_front()</code>，但是实践中一般使用<code>vector</code>，因为其他操作更快。</p>
<h3 id="list">list<a class="headerlink" href="#list" title="Permanent link">&para;</a></h3>
<p>​   A list provides fast insertion anywhere, but no random (indexed)  access.</p>
<table>
<thead>
<tr>
<th>What you want to do</th>
<th>std::vector</th>
<th>std::deque</th>
<th>std::list</th>
</tr>
</thead>
<tbody>
<tr>
<td>Insert/remove in the front</td>
<td>Slow</td>
<td>Fast</td>
<td>Fast</td>
</tr>
<tr>
<td><strong>Insert/remove in the back</strong></td>
<td>Super Fast</td>
<td>Very Fast</td>
<td>Fast</td>
</tr>
<tr>
<td><strong>Indexed Access</strong></td>
<td>Super Fast</td>
<td>Fast</td>
<td>Impossible</td>
</tr>
<tr>
<td>Insert/remove in the middle</td>
<td>Slow</td>
<td>Fast</td>
<td>Very Fast</td>
</tr>
<tr>
<td>Memory usage</td>
<td>Low</td>
<td>High</td>
<td>High</td>
</tr>
<tr>
<td>Combining (splicing/joining)</td>
<td>Slow</td>
<td>Very Slow</td>
<td>Fast</td>
</tr>
<tr>
<td>Stability (iterators/concurrency)</td>
<td>Bad</td>
<td>Very Bad</td>
<td>Good</td>
</tr>
</tbody>
</table>
<blockquote>
<p>wrapper: A wrapper on an object changes how external users can interact  with that object.</p>
</blockquote>
<p><strong>Container adaptors are wrappers in C++!</strong></p>
<h3 id="queue">queue<a class="headerlink" href="#queue" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="n">queue</span><span class="p">.</span><span class="n">push_back</span><span class="p">();</span>
<span class="n">queue</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
</code></pre></div>
<h3 id="stack">stack<a class="headerlink" href="#stack" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="n">stack</span><span class="p">.</span><span class="n">push_back</span><span class="p">();</span>
<span class="n">stack</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
</code></pre></div>
<h3 id="priority_queue">priority_queue<a class="headerlink" href="#priority_queue" title="Permanent link">&para;</a></h3>
<p>​   Adding elements with a priority, always removing the highest priority-element.</p>
<h2 id="associative-containers">Associative Containers<a class="headerlink" href="#associative-containers" title="Permanent link">&para;</a></h2>
<h3 id="set">set<a class="headerlink" href="#set" title="Permanent link">&para;</a></h3>
<p><code>set</code>就是集合，每个元素只出现一次，按键值升序排列。访问元素的时间复杂度是O(logn).</p>
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="c1">//Create an empty set</span>
<span class="n">s</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">k</span><span class="p">);</span><span class="c1">//Add a value k to the set</span>
<span class="n">s</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">k</span><span class="p">);</span><span class="c1">//Remove value k from the set</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">k</span><span class="p">))...</span><span class="c1">//Check if a value k is in the set</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">empty</span><span class="p">())...</span><span class="c1">//Check if vector is empty</span>
</code></pre></div>
<h3 id="map">map<a class="headerlink" href="#map" title="Permanent link">&para;</a></h3>
<p><code>map</code>是c++标准库中定义的关联容器，是键（key）值（value）对的结合体。</p>
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="c1">//Create an empty map</span>
<span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">});</span>
<span class="n">m</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="c1">//Add key k with value v into the map</span>
<span class="n">m</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">k</span><span class="p">);</span><span class="c1">//Remove key k from the map</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">k</span><span class="p">))</span><span class="w"> </span><span class="p">...</span><span class="c1">//Check if key k is in the map</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="p">...</span><span class="c1">//Check if the map is empty</span>
<span class="c1">//Retrieve or overwrite value associated with key k (error if key isn’t in map)</span>
<span class="kt">char</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
<span class="n">m</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="c1">//Retrieve or overwrite value associated with key k (auto-insert if key isn’t in map)</span>
<span class="kt">char</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
<span class="n">m</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
</code></pre></div>
<p>Every <code>std::map&lt;k, v&gt;</code> is actually backed by:  <code>std::pair&lt;const k, v&gt;</code></p>
<div class="highlight"><pre><span></span><code><span class="c1">//Iterating through maps and sets</span>
<span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="p">...,</span><span class="w"> </span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">element</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// do stuff with element</span>
<span class="p">}</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="p">[</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// do stuff with key and value</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="unordered_map-and-unordered_set">unordered_map and unordered_set<a class="headerlink" href="#unordered_map-and-unordered_set" title="Permanent link">&para;</a></h3>
<ul>
<li>Each STL set/map comes with an unordered sibling. They’re almost the same,  except:</li>
<li>Instead of a comparison operator, the set/map type must have a hash function defined for it.<ul>
<li>Simple types, like int, char, bool, double, and even std::string are already supported! </li>
<li>Any containers/collections need you to provide a hash function to use them.</li>
</ul>
</li>
<li>unordered_map/unordered_set are generally faster than map/set.</li>
</ul>
<h2 id="recap_3">Recap<a class="headerlink" href="#recap_3" title="Permanent link">&para;</a></h2>
<ul>
<li>Sequence Containers</li>
<li><code>std::vector</code> - use for almost everything</li>
<li><code>std::deque</code> - use when you need fast insertion to front AND back</li>
<li>Container Adaptors</li>
<li><code>sta::stack</code> and <code>std::queue</code></li>
<li>Associative Containers</li>
<li><code>std::map</code> and <code>std::set</code></li>
<li>if using simple data types/you’re familiar with hash functions, use <code>std::unordered_map</code> and <code>std::unordered_set</code></li>
</ul>
<h1 id="lec6-iterators-and-pointers">Lec6 Iterators and Pointers<a class="headerlink" href="#lec6-iterators-and-pointers" title="Permanent link">&para;</a></h1>
<h2 id="iterators">Iterators<a class="headerlink" href="#iterators" title="Permanent link">&para;</a></h2>
<blockquote>
<p>A way to access all containers programmatically!</p>
</blockquote>
<ul>
<li>Iterators are objects that point to elements inside containers.</li>
<li>Each STL container has its own iterator, but all of these iterators exhibit a similar  behavior!</li>
<li>Generally, STL iterators support the following operations:</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&gt;</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">::</span><span class="n">iterator</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="c1">// at 0</span>
<span class="o">++</span><span class="n">iter</span><span class="p">;</span><span class="w"> </span><span class="c1">// at 1</span>
<span class="o">*</span><span class="n">iter</span><span class="p">;</span><span class="w"> </span><span class="c1">// 1</span>
<span class="p">(</span><span class="n">iter</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">());</span><span class="w"> </span><span class="c1">// can compare iterator equality</span>
<span class="k">auto</span><span class="w"> </span><span class="n">second_iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iter</span><span class="p">;</span><span class="w"> </span><span class="c1">// &quot;copy construction&quot;</span>
</code></pre></div>
<p>Types:</p>
<ul>
<li>Input Iterator：只能单步向前迭代元素，不允许修改由该类迭代器引用的元素。</li>
<li>Output Iterator：该类迭代器和Input Iterator极其相似，也只能单步向前迭代元素，不同的是该类迭代器对元素只有写的权力。</li>
<li>Forward Iterator：该类迭代器可以在一个正确的区间中进行读写操作，它拥有Input Iterator的所有特性，和Output Iterator的部分特性，以及单步向前迭代元素的能力。</li>
<li>Bidirectional Iterator：该类迭代器是在Forward Iterator的基础上提供了单步向后迭代元素的能力。</li>
<li>Random Access Iterator：该类迭代器能完成上面所有迭代器的工作，它自己独有的特性就是可以像指针那样进行算术计算，而不是仅仅只有单步向前或向后迭代。</li>
</ul>
<p>Explain:</p>
<ul>
<li>
<p>There are a few different types of iterators,  since containers are different!</p>
</li>
<li>
<p>All iterators can be incremented (++) </p>
</li>
<li>
<p>Input iterators can be on the RHS (right  hand side) of an = sign: <code>auto elem = *it;</code></p>
</li>
<li>
<p>Output iterators can be on the LHS of = : <code>*elem = value;</code></p>
</li>
<li>
<p>Random access iterators support indexing  by integers!</p>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="n">it</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="c1">// move forward by 3</span>
<span class="n">it</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">70</span><span class="p">;</span><span class="w"> </span><span class="c1">// move backwards by 70</span>
<span class="k">auto</span><span class="w"> </span><span class="n">elem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">it</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span><span class="w"> </span><span class="c1">// offset by 5</span>
</code></pre></div>
<p>Why ++iter and not iter++?</p>
<p>​   <strong>Answer</strong>: ++iter returns the value after being incremented! iter++ returns the previous value and then increments it. (wastes just a bit of time)</p>
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="p">{{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">}};</span>
<span class="k">auto</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="c1">// what is *iter?</span>
<span class="o">++</span><span class="n">iter</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">iter2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iter</span><span class="p">;</span><span class="w"> </span><span class="c1">// what is (*iter2).second?</span>
<span class="o">++</span><span class="n">iter2</span><span class="p">;</span><span class="w"> </span><span class="c1">// now what is (*iter).first?</span>
<span class="c1">// ++iter: go to the next element</span>
<span class="c1">// *iter: retrieve what&#39;s at iter&#39;s position</span>
<span class="c1">// copy constructor: create another iterator pointing to the same thing</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">set</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">};</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">set</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">set</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">iter</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">elem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">iter</span><span class="p">;</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">elem</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">map</span><span class="p">{{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">}};</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">map</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">iter</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="p">[</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">iter</span><span class="p">;</span><span class="w"> </span><span class="c1">// structured binding!</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;:&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">set</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">};</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">elem</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">set</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">elem</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">map</span><span class="p">{{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">}};</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="p">[</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">map</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;:&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="k">auto</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">).</span><span class="n">first</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
<span class="c1">//These are equivalent.</span>
</code></pre></div>
<h2 id="pointers">Pointers<a class="headerlink" href="#pointers" title="Permanent link">&para;</a></h2>
<ul>
<li>When variables are created, they're  given an address in memory.</li>
<li>Pointers are objects that store an  address and type of a variable.</li>
<li>To get the value of a pointer, we can dereference it (get the object referenced by  the pointer)</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">pointerToInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="c1">// creates pointer to int</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">pointerToInt</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// 5</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pair</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">};</span><span class="w"> </span><span class="c1">// creates pair</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">pointerToPair</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pair</span><span class="p">;</span><span class="w"> </span><span class="c1">// creates pointer to pair</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">pair</span><span class="p">).</span><span class="n">first</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// 1</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pair</span><span class="o">-&gt;</span><span class="n">first</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// 1</span>
</code></pre></div>
<h2 id="pointers-vs-iterators">Pointers vs. Iterators<a class="headerlink" href="#pointers-vs-iterators" title="Permanent link">&para;</a></h2>
<ul>
<li>Iterators are a form of pointers!</li>
<li>Pointers are more generic iterators</li>
<li>can point to any object, not just elements in a container!</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">lands</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Xadia&quot;</span><span class="p">;</span>
<span class="c1">// iterator</span>
<span class="k">auto</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lands</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
<span class="c1">// syntax for a pointer. don&#39;t worry about the specifics if you&#39;re in 106B! they&#39;ll be discussed in the latter half of the course.</span>
<span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">firstChar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">lands</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</code></pre></div>
<h1 id="lec7-classes">Lec7 Classes<a class="headerlink" href="#lec7-classes" title="Permanent link">&para;</a></h1>
<blockquote>
<p>Containers are all classes defined  in the STL!</p>
<p>Iterators are (basically) pointers! More on that later</p>
<p>Class: A programmerdefined custom type. An  abstraction of an object or data type.</p>
</blockquote>
<h2 id="but-dont-structs-do-that">But don’t structs do that?<a class="headerlink" href="#but-dont-structs-do-that" title="Permanent link">&para;</a></h2>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">Student</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">;</span><span class="w"> </span><span class="c1">// these are called fields</span>
<span class="w">    </span><span class="n">string</span><span class="w"> </span><span class="n">state</span><span class="p">;</span><span class="w"> </span><span class="c1">// separate these by semicolons</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">age</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">Student</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="s">&quot;Frankie&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;MN&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">21</span><span class="p">};</span>
</code></pre></div>
<p><strong>Issues with structs</strong></p>
<ul>
<li>Public access to all internal state data by default</li>
<li>Users of struct need to explicitly initialize each data member.</li>
</ul>
<p><strong>Classes provide their users with a public interface and separate this from a private implementation.</strong></p>
<h2 id="turning-student-into-a-class-header-file--cpp-file">Turning Student into a class: Header File + .cpp File:<a class="headerlink" href="#turning-student-into-a-class-header-file--cpp-file" title="Permanent link">&para;</a></h2>
<div class="highlight"><pre><span></span><code><span class="c1">//student.h</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Student</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">getName</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">setName</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">getAge</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">setAge</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">age</span><span class="p">);</span>

<span class="w">    </span><span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">state</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">age</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">//student.cpp</span>
<span class="cp">#include student.h</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span>
<span class="nf">Student::getName</span><span class="p">(){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">Student::setName</span><span class="p">(){</span>
<span class="w">    </span><span class="k">this</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">Student::getAge</span><span class="p">(){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">age</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">Student::setAge</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">age</span><span class="p">){</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">age</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">this</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">age</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="n">error</span><span class="p">(</span><span class="s">&quot;Age cannot be negative!&quot;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>Function definitions with namespaces!</strong></p>
<ul>
<li>
<p>namespace_name::name in a function prototype means  “this is the implementation for an interface function in  namespace_name ”</p>
</li>
<li>
<p>Inside the {...} the private member variables for  namespace_name will be in scope!</p>
</li>
</ul>
<p><code>std::string Student::getName(){...}</code></p>
<p><strong>The this keyword!</strong></p>
<ul>
<li>Here, we mean “set the Student private member variable name equal to the parameter name ”</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">Student::setName</span><span class="p">(){</span>
<span class="w">    </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>this-&gt;element_name means “the item in this Student  object with name element_name”. Use this for naming  conflicts!</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">Student::setName</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">){</span>
<span class="w">    </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">name</span><span class="p">;</span><span class="w"> </span><span class="c1">//better!</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="constructors-and-destructors">Constructors and Destructors<a class="headerlink" href="#constructors-and-destructors" title="Permanent link">&para;</a></h2>
<p><strong>constructors:</strong></p>
<ul>
<li>Define how the member variables of an object is initialized</li>
<li>What gets called when you first create a Student object</li>
<li>Overloadable!</li>
</ul>
<p><strong>destructors:</strong></p>
<ul>
<li>deleteing (almost) always happens in the destructor of a class!</li>
<li>The destructor is defined using Class_name::~Class_name()</li>
<li>No one ever explicitly calls it! Its called when Class_name  object go out of scope!</li>
<li>Just like all member functions, declare it in the .h and  implement in the .cpp!</li>
</ul>
<p>构造函数就是一个与类名相同的函数，在生成这个类的时候就会被调用，用来初始化这个类。</p>
<p>与构造函数相对的是析构函数，在关闭文件、释放内存前释放资源，名称是类名前加一个<code>~</code></p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Entity</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="n">Y</span><span class="p">;</span>
<span class="w">    </span><span class="n">Entity</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Entity is constructed!&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="o">~</span><span class="n">Entity</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Entity is destructed!&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">Function</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Entity</span><span class="w"> </span><span class="n">e</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span><span class="w">  </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Function</span><span class="p">();</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="public-and-private-sections">Public and Private Sections<a class="headerlink" href="#public-and-private-sections" title="Permanent link">&para;</a></h2>
<blockquote>
<p>Class: A programmerdefined custom type. An  abstraction of an object or data type.</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="c1">//student.h</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Student</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">getName</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">setName</span><span class="p">(</span><span class="n">string</span><span class="w"> </span>
<span class="w">    </span><span class="n">name</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">getAge</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">setAge</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">age</span><span class="p">);</span>
<span class="w">    </span><span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">state</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">age</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p><strong>Public section:</strong></p>
<ul>
<li>Users of the Student object can  directly access anything here!</li>
<li>Defines interface for interacting with the private member variables!</li>
</ul>
<p><strong>Private section:</strong></p>
<ul>
<li>Usually contains all member variables</li>
<li>Users can’t access or modify anything in the private section</li>
</ul>
<h2 id="one-last-thing-arrays">One last thing… Arrays<a class="headerlink" href="#one-last-thing-arrays" title="Permanent link">&para;</a></h2>
<div class="highlight"><pre><span></span><code><span class="c1">//int * is the type of an int array variable</span>
<span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">my_int_array</span><span class="p">;</span>
<span class="c1">//my_int_array is a pointer!</span>
<span class="c1">//this is how you initialize an array</span>
<span class="n">my_int_array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="c1">//this is how you index into an array</span>
<span class="kt">int</span><span class="w"> </span><span class="n">one_element</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_int_array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="c1">//Arrays are memory WE allocate, so we need to give instructions for when to deallocate that memory!</span>
<span class="c1">//When we are done using our array, we need to delete [] it!</span>
<span class="k">delete</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">my_int_array</span><span class="p">;</span>
</code></pre></div>
<h1 id="lec8-template-classes-and-const-correctness">Lec8 Template Classes and Const  Correctness<a class="headerlink" href="#lec8-template-classes-and-const-correctness" title="Permanent link">&para;</a></h1>
<h2 id="template-classes">Template Classes<a class="headerlink" href="#template-classes" title="Permanent link">&para;</a></h2>
<blockquote>
<p>Fundamental Theorem of Software Engineering: Any  problem can be solved by  adding enough layers of  indirection.</p>
</blockquote>
<p><strong>The problem with IntVector</strong></p>
<ul>
<li>Vectors should be able to contain any data type!</li>
</ul>
<p>Solution? Create StringVector, DoubleVector, BoolVector etc..</p>
<ul>
<li>
<p>What if we want to make a vector of struct Students?</p>
</li>
<li>
<p>How are we supposed to know about every custom class?</p>
</li>
<li>
<p>What if we don’t want to write a class for every type we can  think of?</p>
</li>
</ul>
<p><code>SOLUTION: Template classes!</code></p>
<blockquote>
<p>Template Class: A class that is parametrized over some number of types. A class that is comprised of member variables of a general type/types.</p>
</blockquote>
<p><strong>Template Classes You’ve Used</strong></p>
<p>Vectors/Maps/Sets... Pretty much all containers!</p>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">right</span><span class="p">){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">right</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//隐式实例化</span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(){</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">a1</span><span class="o">=</span><span class="mi">10</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">b1</span><span class="o">=</span><span class="mf">10.0</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//add(a1,b1);</span>
<span class="w">    </span><span class="n">add</span><span class="p">(</span><span class="n">a1</span><span class="p">,(</span><span class="kt">int</span><span class="p">)</span><span class="n">b1</span><span class="p">);</span><span class="c1">//强制类型转换</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//显式实例化</span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(){</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="o">=</span><span class="mi">10</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">b</span><span class="o">=</span><span class="mf">10.0</span><span class="p">;</span>
<span class="w">    </span><span class="n">add</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>Writing a Template Class: Syntax</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1">//mypair.h</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">First</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">Second</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">MyPair</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">        </span><span class="n">First</span><span class="w"> </span><span class="n">getFirst</span><span class="p">();</span>
<span class="w">        </span><span class="n">Second</span><span class="w"> </span><span class="nf">getSecond</span><span class="p">();</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">setFirst</span><span class="p">(</span><span class="n">First</span><span class="w"> </span><span class="n">f</span><span class="p">);</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">setSecond</span><span class="p">(</span><span class="n">Second</span><span class="w"> </span><span class="n">f</span><span class="p">);</span>
<span class="w">    </span><span class="k">private</span><span class="o">:</span>
<span class="w">        </span><span class="n">First</span><span class="w"> </span><span class="n">first</span><span class="p">;</span>
<span class="w">        </span><span class="n">Second</span><span class="w"> </span><span class="n">second</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">//mypair.cpp</span>
<span class="cp">#include “mypair.h”</span>
<span class="c1">//如果没有下面这句话会Compile error! Must announce every member function is templated</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">First</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">Second</span><span class="o">&gt;</span>
<span class="n">First</span><span class="w"> </span><span class="n">MyPair</span><span class="o">::</span><span class="n">getFirst</span><span class="p">(){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">first</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Second</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">First</span><span class="o">&gt;</span>
<span class="w">    </span><span class="n">Second</span><span class="w"> </span><span class="n">MyPair</span><span class="o">::</span><span class="n">getSecond</span><span class="p">(){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">second</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>Member Types</strong></p>
<ul>
<li>
<p>Sometimes, we need a name for a type that is dependent on  our template types</p>
</li>
<li>
<p>iterator is a member type of vector</p>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">::</span><span class="n">iterator</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
</code></pre></div>
<p>Summary:</p>
<ul>
<li>Used to make sure your clients have a standardized way to  access important types.</li>
<li>Lives in your namespace: <code>vector&lt;T&gt;::iterator</code>.</li>
<li>After class specifier, you can use the alias directly (e.g. inside  function arguments, inside function body).</li>
<li>Before class specifier, use typename.</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="c1">// main.cpp</span>
<span class="cp">#include “vector.h”</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="n">a</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="c1">// vector.h</span>
<span class="cp">#include “vector.h”</span><span class="c1">//注意是在.h文件中引入verctor.h，而不是在verctor.cpp中引入!!!</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="n">T</span><span class="w"> </span><span class="nf">at</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="p">};</span>
<span class="c1">// vector.cpp</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">at</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// oops</span>
<span class="p">}</span>
</code></pre></div>
<p>​   <strong>Templates don’t emit code until instantiated</strong>, so include the .cpp in the .h instead of the other way around!</p>
<h2 id="const-correctness">Const Correctness<a class="headerlink" href="#const-correctness" title="Permanent link">&para;</a></h2>
<blockquote>
<p>const: keyword  indicating a variable,  function or parameter  can’t be modified</p>
</blockquote>
<p><strong>const indicates a variable can’t be modified!</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">};</span>
<span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">c_vec</span><span class="p">{</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">};</span><span class="w"> </span><span class="c1">// a const variable</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="p">;</span><span class="w"> </span><span class="c1">// a regular reference</span>
<span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">c_ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="p">;</span><span class="w"> </span><span class="c1">// a const reference</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span><span class="w"> </span><span class="c1">// OKAY</span>
<span class="n">c_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">9</span><span class="p">);</span><span class="w"> </span><span class="c1">// BAD - const</span>
<span class="n">ref</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w"> </span><span class="c1">// OKAY</span>
<span class="n">c_ref</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span><span class="w"> </span><span class="c1">// BAD - const</span>
</code></pre></div>
<p><strong>Can’t declare non-const reference to const variable!</strong></p>
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">c_vec</span><span class="p">{</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">};</span><span class="w"> </span><span class="c1">// a const variable</span>
<span class="c1">// fixed</span>
<span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">bad_ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c_vec</span><span class="p">;</span>
<span class="c1">// BAD - Can&#39;t declare a non-const reference as equal</span>
<span class="c1">// to a const reference!</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c_ref</span><span class="p">;</span>
</code></pre></div>
<p><strong>const &amp; subtleties with auto</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">};</span>
<span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">c_vec</span><span class="p">{</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">c_ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">copy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c_ref</span><span class="p">;</span><span class="w"> </span><span class="c1">// a non-const copy</span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">copy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c_ref</span><span class="p">;</span><span class="w"> </span><span class="c1">// a const copy</span>
<span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ref</span><span class="p">;</span><span class="w"> </span><span class="c1">// a non-const reference</span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">c_aref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ref</span><span class="p">;</span><span class="w"> </span><span class="c1">// a const reference</span>
</code></pre></div>
<p><strong>Why const?</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1">// Find the typo in this code</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">x</span><span class="o">==</span><span class="mi">2</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">y</span><span class="o">==</span><span class="mi">3</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">x</span><span class="o">==</span><span class="mi">1</span><span class="p">))</span>
<span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">y</span><span class="o">==</span><span class="n">x</span><span class="mi">-1</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">x</span><span class="o">==</span><span class="mi">-1</span><span class="o">||</span><span class="n">y</span><span class="o">=</span><span class="mi">-1</span><span class="p">))</span><span class="c1">//轻松发现这里的y==-1写错了</span>
<span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;b&#39;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">x</span><span class="o">==</span><span class="mi">3</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">y</span><span class="o">==</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">))</span>
<span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;c&#39;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="c1">// Overly ambitious functions in application code</span>
<span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">countPopulation</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Planet</span><span class="o">&amp;</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Hats are the cornerstone of modern society</span>
<span class="w">    </span><span class="n">addLittleHat</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w"> </span><span class="c1">//compile error</span>
<span class="w">    </span><span class="c1">// Guaranteed no more population growth, all future calls will be faster</span>
<span class="w">    </span><span class="n">sterilize</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w"> </span><span class="c1">//compile error</span>
<span class="w">    </span><span class="c1">// Optimization: destroy planet</span>
<span class="w">    </span><span class="c1">// This makes population counting very fast</span>
<span class="w">    </span><span class="n">deathStar</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w"> </span><span class="c1">//compile error</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//How does the algorithm above work?</span>
<span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">countPopulation</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Planet</span><span class="o">&amp;</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">addLittleHat</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w"> </span><span class="c1">//p is a const reference here</span>

<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">addLittleHat</span><span class="p">(</span><span class="n">Planet</span><span class="o">&amp;</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="c1">//p is a (non const) reference here</span>
<span class="w">    </span><span class="n">p</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">something</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span>
<span class="c1">//So it will become compile error</span>
</code></pre></div>
<p>Calling addLittleHat on p is  like setting a non const  variable equal to a const  one, it’s not allowed!</p>
<p><strong>Const and Classes</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1">//student.cpp</span>
<span class="cp">#include student.h</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">Student::getName</span><span class="p">(){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">name</span><span class="p">;</span><span class="w"> </span><span class="c1">//we can access name here!</span>
<span class="p">}</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">Student::setName</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">){</span>
<span class="w">    </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">name</span><span class="p">;</span><span class="w"> </span><span class="c1">//resolved!</span>
<span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">Student::getAge</span><span class="p">(){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">age</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">Student::setAge</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">age</span><span class="p">){</span>
<span class="c1">//We can define what “age” means!</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">age</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">        </span><span class="k">this</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">age</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="n">error</span><span class="p">(</span><span class="s">&quot;Age cannot be negative!&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//student.h</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Student</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">getName</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">setName</span><span class="p">(</span><span class="n">string</span><span class="w"> </span>
<span class="w">    </span><span class="n">name</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">getAge</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">setAge</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">age</span><span class="p">);</span>

<span class="w">    </span><span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">state</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">age</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>Using a const Student:</p>
<div class="highlight"><pre><span></span><code><span class="c1">//main.cpp</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">stringify</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Student</span><span class="o">&amp;</span><span class="w"> </span><span class="n">s</span><span class="p">){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">getName</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot; is &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">getAge</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span>
<span class="w">    </span><span class="s">&quot; years old.&quot;</span><span class="w"> </span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//compile error!</span>
</code></pre></div>
<ul>
<li>The compiler doesn’t know getName and getAge don’t modify s!</li>
<li>We need to promise that it doesn’t by defining them as <strong>const functions</strong></li>
<li>Add const to the end of function signatures!</li>
</ul>
<p>So, we make Student const-correct:</p>
<div class="highlight"><pre><span></span><code><span class="c1">//student.cpp</span>
<span class="cp">#include student.h</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">Student::getName</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">{</span><span class="c1">//there</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">name</span><span class="p">;</span><span class="w"> </span>
<span class="p">}</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">Student::setName</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">){</span>
<span class="w">    </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">name</span><span class="p">;</span><span class="w"> </span>
<span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">Student::getAge</span><span class="p">()</span><span class="k">const</span><span class="p">{</span><span class="c1">//there</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">age</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">Student::setAge</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">age</span><span class="p">){</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">age</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">        </span><span class="k">this</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">age</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="n">error</span><span class="p">(</span><span class="s">&quot;Age cannot be negative!&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//student.h</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Student</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">getName</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="c1">//there</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">setName</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">getAge</span><span class="w"> </span><span class="nf">const</span><span class="p">();</span><span class="c1">//there</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">setAge</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">age</span><span class="p">);</span>
<span class="w">    </span><span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">state</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">age</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<blockquote>
<p>const-interface: All member  functions marked const in  a class definition. Objects of  type const ClassName may only use the  const-interface.</p>
</blockquote>
<p>Making RealVector‘s const-interface:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">StrVector</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">iterator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">kInitialSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/*...*/</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">size</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">empty</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">at</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">indx</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">insert</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">elem</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">push_back</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">elem</span><span class="p">);</span>
<span class="w">    </span><span class="n">iterator</span><span class="w"> </span><span class="nf">begin</span><span class="p">();</span>
<span class="w">    </span><span class="n">iterator</span><span class="w"> </span><span class="nf">end</span><span class="p">();</span>
<span class="w">    </span><span class="cm">/*...*/</span>
<span class="p">}</span>
</code></pre></div>
<p>Should begin() and end() be const?</p>
<p><strong>Answer</strong>: 虽然这两个函数都是const的，但是它们给我们返回了一个可以变化的iterator，所以会报错！</p>
<p><strong>Solution</strong>: cbegin() and cend()</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">StrVector</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">     </span><span class="k">using</span><span class="w"> </span><span class="n">iterator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span><span class="p">;</span>
<span class="w">     </span><span class="k">using</span><span class="w"> </span><span class="n">const_</span><span class="w"> </span><span class="n">iterator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span><span class="p">;</span>
<span class="w">     </span><span class="cm">/*...*/</span>
<span class="w">     </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">size</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">     </span><span class="kt">bool</span><span class="w"> </span><span class="nf">empty</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">     </span><span class="cm">/*...*/</span>
<span class="w">     </span><span class="kt">void</span><span class="w"> </span><span class="nf">push_back</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">elem</span><span class="p">);</span>
<span class="w">    </span><span class="n">iterator</span><span class="w"> </span><span class="nf">begin</span><span class="p">();</span>
<span class="w">    </span><span class="n">iterator</span><span class="w"> </span><span class="nf">end</span><span class="p">();</span>
<span class="w">    </span><span class="n">const_iterator</span><span class="w"> </span><span class="nf">begin</span><span class="p">()</span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="n">const_iterator</span><span class="w"> </span><span class="nf">end</span><span class="p">()</span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/*...*/</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">printVec</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">RealVector</span><span class="o">&amp;</span><span class="w"> </span><span class="n">vec</span><span class="p">){</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;{ &quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">cbegin</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">cend</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">){</span>
<span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">it</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">cout</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; }&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">cout</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//Fixed! And now we can’t set *it equal to something: it will be a compile error!</span>
</code></pre></div>
<p><strong>const iterator vs const_iterator: Nitty Gritty</strong></p>
<div class="highlight"><pre><span></span><code><span class="k">using</span><span class="w"> </span><span class="n">iterator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">const_iterator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="n">iterator</span><span class="w"> </span><span class="n">it_c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="c1">//string * const, const ptr to non-const obj</span>
<span class="o">*</span><span class="n">it_c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;hi&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">//OK! it_c is a const pointer to non-const object</span>
<span class="n">it_c</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="c1">//not ok! cant change where a const pointer points! </span>
<span class="n">const_iterator</span><span class="w"> </span><span class="n">c_it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">cbegin</span><span class="p">();</span><span class="w"> </span><span class="c1">//const string*, a non-const ptr to const obj</span>
<span class="n">c_it</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="c1">// totally ok! The pointer itself is non-const</span>
<span class="o">*</span><span class="n">c_it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;hi&quot;</span><span class="w"> </span><span class="c1">// not ok! Can’t change underlying const object</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">c_it</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">//allowed! Can always read a const object, just can&#39;t change</span>
<span class="c1">//const string * const, const ptr to const obj</span>
<span class="k">const</span><span class="w"> </span><span class="n">const_iterator</span><span class="w"> </span><span class="n">c_it_c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">cbegin</span><span class="p">();</span><span class="w"> </span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">c_it_c</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; points to &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">c_it_c</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">//only reads are allowed!</span>
</code></pre></div>
<h2 id="recap_4">Recap<a class="headerlink" href="#recap_4" title="Permanent link">&para;</a></h2>
<h3 id="template-classes_1">Template classes<a class="headerlink" href="#template-classes_1" title="Permanent link">&para;</a></h3>
<ul>
<li>Add <code>template&lt;typename T1, typename T2 ...&gt;</code> before class definition in .h</li>
<li>Add <code>template&lt;typename T1, typename T2 ...&gt;</code> before all  function signature in .cpp</li>
<li>When returning nested types (like iterator types), put <code>template&lt;typename T1, typename T2 ...&gt;::member_type</code> as return type, not  just <code>member_type</code></li>
<li>Templates don’t emit code until instantiated, so <code>#include</code> the  .cpp file in the .h file, not the other way around</li>
</ul>
<h3 id="const-and-const-correctness">Const and Const-correctness<a class="headerlink" href="#const-and-const-correctness" title="Permanent link">&para;</a></h3>
<ul>
<li>Use const parameters and variables wherever you can in application code</li>
<li>Every member function of a class that doesn’t change its member variables should be marked <code>const</code></li>
<li>auto will drop all const and &amp;, so be sure to specify</li>
<li>Make iterators and const_iterators for all your classes!</li>
<li><strong>const iterator</strong> = cannot increment the iterator, can dereference and change underlying value</li>
<li><strong>const_iterator</strong> = can increment the iterator, cannot dereference and change underlying value</li>
<li><strong>const const_iterator</strong> = cannot increment iterator, cannot dereference and change underlying value</li>
</ul>
<h1 id="lec9-template-functions">Lec9 Template Functions<a class="headerlink" href="#lec9-template-functions" title="Permanent link">&para;</a></h1>
<h2 id="generic-programming">Generic Programming<a class="headerlink" href="#generic-programming" title="Permanent link">&para;</a></h2>
<h3 id="generic-c">Generic C++<a class="headerlink" href="#generic-c" title="Permanent link">&para;</a></h3>
<ul>
<li>Allow data types to be parameterized (C++ entities that work on any  datatypes)</li>
<li>Template classes achieve generic classes</li>
<li><strong>How can we write methods that work on any data type?</strong></li>
</ul>
<h3 id="function-to-get-the-min-of-two-ints">Function to get the min of two ints<a class="headerlink" href="#function-to-get-the-min-of-two-ints" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">myMin</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="k">auto</span><span class="w"> </span><span class="n">min_int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myMin</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"> </span><span class="c1">// 1</span>
<span class="k">auto</span><span class="w"> </span><span class="n">min_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myMin</span><span class="p">(</span><span class="s">&quot;Sathya&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Frankie&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// error!</span>
</code></pre></div>
<p><strong>One solution: overloaded functions</strong></p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">myMin</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// exactly the same except for types</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">myMin</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">min_int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myMin</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"> </span><span class="c1">// 1</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">min_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myMin</span><span class="p">(</span><span class="s">&quot;Sathya&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Frankie&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Frankie</span>
<span class="p">}</span>
</code></pre></div>
<p>But what about comparing other data types, like doubles, characters, and  complex objects?</p>
<h2 id="template-functions">Template functions<a class="headerlink" href="#template-functions" title="Permanent link">&para;</a></h2>
<blockquote>
<p>Writing reusable, unique code with no duplication!</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="c1">//generic, &quot;template&quot; functions</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Type</span><span class="o">&gt;</span>
<span class="n">Type</span><span class="w"> </span><span class="n">myMin</span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//Here, &quot;class&quot; is an alternative keyword to typename. </span>
<span class="c1">//They&#39;re 100% equivalent in template function declarations!</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">Type</span><span class="o">&gt;</span>
<span class="n">Type</span><span class="w"> </span><span class="n">myMin</span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//Default value for class template parameter</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Type</span><span class="o">=</span><span class="kt">int</span><span class="o">&gt;</span>
<span class="n">Type</span><span class="w"> </span><span class="n">myMin</span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// int main() {} will be omitted from future examples</span>
<span class="c1">// we&#39;ll instead show the code that&#39;d go inside it</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myMin</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// 3</span>

<span class="c1">//let compiler deduce return type</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">U</span><span class="o">&gt;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">smarterMyMin</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myMin</span><span class="p">(</span><span class="mf">3.2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// 3.2</span>
</code></pre></div>
<h3 id="template-type-deduction---case-1">Template type deduction - case 1<a class="headerlink" href="#template-type-deduction---case-1" title="Permanent link">&para;</a></h3>
<p>If the template function parameters are regular, pass-by-value parameters: </p>
<ol>
<li>Ignore the "&amp;"</li>
<li>After ignoring "&amp;", ignore const too</li>
</ol>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Type</span><span class="o">&gt;</span>
<span class="n">Type</span><span class="w"> </span><span class="n">addFive</span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="c1">// only works for types that support &quot;+&quot;</span>
<span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span>
<span class="n">addFive</span><span class="p">(</span><span class="n">a</span><span class="p">);</span><span class="w"> </span><span class="c1">// Type is int</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="n">addFive</span><span class="p">(</span><span class="n">b</span><span class="p">);</span><span class="w"> </span><span class="c1">// Type is still int</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="n">addFive</span><span class="p">(</span><span class="n">c</span><span class="p">);</span><span class="w"> </span><span class="c1">// even now, Type is still int</span>
</code></pre></div>
<h3 id="template-type-deduction---case-2">Template type deduction - case 2<a class="headerlink" href="#template-type-deduction---case-2" title="Permanent link">&para;</a></h3>
<p>If the template function parameters are references or pointers, this is how types (e.g. Type)  are deduced:</p>
<ol>
<li>Ignore the "&amp;" </li>
<li>Match the type of parameters to inputted arguments</li>
<li>Add on const after</li>
</ol>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Type</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">makeMin</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Type</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Type</span><span class="o">&amp;</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="o">&amp;</span><span class="w"> </span><span class="n">minObj</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="c1">//a and b are references to const values</span>
<span class="w">    </span><span class="c1">// set minObj to the min of a and b instead of returning.</span>
<span class="w">    </span><span class="n">minObj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w"> </span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">21</span><span class="p">;</span><span class="w"> </span>
<span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="p">;</span><span class="w"> </span>
<span class="n">myMin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">);</span><span class="w"> </span><span class="c1">// Type is deduced to be int</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// 20</span>
</code></pre></div>
<p><strong>behind the scenes</strong></p>
<ul>
<li>
<p>Normal functions are created during compile time, and used in runtime</p>
</li>
<li>
<p>Template functions are not compiled until used by the code</p>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Type</span><span class="o">&gt;</span>
<span class="n">Type</span><span class="w"> </span><span class="n">myMin</span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myMin</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// 3</span>
</code></pre></div>
<ul>
<li>
<p>The compiler deduces the parameter types and generates a unique  function specifically for each time the template function is called</p>
</li>
<li>
<p>After compilation, the compiled code looks as if you had written each  instantiated version of the function yourself</p>
</li>
</ul>
<h2 id="template-metaprogramming">Template Metaprogramming<a class="headerlink" href="#template-metaprogramming" title="Permanent link">&para;</a></h2>
<blockquote>
<ul>
<li>Normal code runs during run time.</li>
<li>TMP -&gt; run code during compile time</li>
<li>make compiled code packages smaller</li>
<li>speed up code when it's actually running</li>
</ul>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">n</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Factorial</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Factorial</span><span class="o">&lt;</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;::</span><span class="n">value</span><span class="w"> </span><span class="p">};</span>
<span class="p">};</span>
<span class="k">template</span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="c1">// template class &quot;specialization&quot;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Factorial</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">};</span>
<span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">Factorial</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">&gt;::</span><span class="n">value</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// prints 3628800, but run during compile time!</span>
</code></pre></div>
<h3 id="how-can-tmp-actually-be-used">How can TMP actually be used?<a class="headerlink" href="#how-can-tmp-actually-be-used" title="Permanent link">&para;</a></h3>
<ul>
<li>TMP was actually discovered (not invented, discovered) recently!</li>
<li>Where can TMP be applied</li>
<li>Ensuring dimensional unit correctness</li>
<li>Optimizing matrix operations</li>
<li>Generating custom design pattern implementation<ul>
<li>policy-based design (templates generating their own templates)</li>
</ul>
</li>
</ul>
<h2 id="why-write-generic-functions">Why write generic functions?<a class="headerlink" href="#why-write-generic-functions" title="Permanent link">&para;</a></h2>
<div class="highlight"><pre><span></span><code><span class="n">Count</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">times</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="n">appears</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">.</span><span class="w"> </span>
<span class="n">Count</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">times</span><span class="w"> </span><span class="s">&quot;Y&quot;</span><span class="w"> </span><span class="n">appears</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="p">.</span><span class="w"> </span>
<span class="n">Count</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">times</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="n">appears</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">second</span><span class="w"> </span><span class="n">half</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">.</span><span class="w"> </span>
<span class="n">Count</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">times</span><span class="w"> </span><span class="s">&quot;X&quot;</span><span class="w"> </span><span class="n">appear</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">second</span><span class="w"> </span><span class="n">half</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">.</span>
<span class="c1">//By using generic functions, we can solve each of these problems with a single function!</span>
</code></pre></div>
<p><strong>Counting Occurrences</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1">//Attempt 1</span>
<span class="c1">//count strings</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">count_occurrences</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">target</span><span class="p">){</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">){</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">target</span><span class="p">)</span><span class="w"> </span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
<span class="nl">Usage</span><span class="p">:</span><span class="w"> </span><span class="n">count_occurrences</span><span class="p">({</span><span class="s">&quot;Xadia&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Drakewood&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Innean&quot;</span><span class="p">},</span><span class="w"> </span><span class="s">&quot;Xadia&quot;</span><span class="p">);</span><span class="w"> </span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="c1">//Attempt 2</span>
<span class="c1">//generalize this beyond just strings</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">DataType</span><span class="o">&gt;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">count_occurrences</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">DataType</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec</span><span class="p">,</span><span class="w"> </span><span class="n">DataType</span><span class="w"> </span><span class="n">target</span><span class="p">){</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">){</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">target</span><span class="p">)</span><span class="w"> </span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
<span class="nl">Usage</span><span class="p">:</span><span class="w"> </span><span class="n">count_occurrences</span><span class="p">({</span><span class="s">&quot;Xadia&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Drakewood&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Innean&quot;</span><span class="p">},</span><span class="w"> </span><span class="s">&quot;Xadia&quot;</span><span class="p">);</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="c1">//Attempt 3</span>
<span class="c1">//generalize this beyond just vectors</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Collection</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">DataType</span><span class="o">&gt;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">count_occurrences</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Collection</span><span class="o">&amp;</span><span class="w"> </span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="n">DataType</span><span class="w"> </span><span class="n">target</span><span class="p">){</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">arr</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">){</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">target</span><span class="p">)</span><span class="w"> </span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
<span class="nl">Usage</span><span class="p">:</span><span class="w"> </span><span class="n">count_occurrences</span><span class="p">({</span><span class="s">&quot;Xadia&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Drakewood&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Innean&quot;</span><span class="p">},</span><span class="w"> </span><span class="s">&quot;Xadia&quot;</span><span class="p">);</span><span class="w"> </span>
<span class="c1">//The collection may not be indexable!</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="c1">//Attempt 4</span>
<span class="c1">//Solve the problem in Attempt 3</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">InputIt</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">DataType</span><span class="o">&gt;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">count_occurrences</span><span class="p">(</span><span class="n">InputIt</span><span class="w"> </span><span class="n">begin</span><span class="p">,</span><span class="w"> </span><span class="n">InputIt</span><span class="w"> </span><span class="n">end</span><span class="p">,</span><span class="w"> </span><span class="n">DataType</span><span class="w"> </span><span class="n">target</span><span class="p">){</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">initialization</span><span class="p">;</span><span class="w"> </span><span class="n">end</span><span class="o">-</span><span class="n">condition</span><span class="p">;</span><span class="w"> </span><span class="n">increment</span><span class="p">){</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">element</span><span class="w"> </span><span class="n">access</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">target</span><span class="p">)</span><span class="w"> </span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lands</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="s">&quot;Xadia&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Drakewood&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Innean&quot;</span><span class="p">};</span>
<span class="nl">Usage</span><span class="p">:</span><span class="w"> </span><span class="n">count_occurrences</span><span class="p">(</span><span class="n">lands</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">lands</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="s">&quot;Xadia&quot;</span><span class="p">);</span><span class="w"> </span>
<span class="c1">//We manually pass in begin and end so that we can customize our search bounds.</span>
</code></pre></div>
<h1 id="lec10-functions-and-lambdas">Lec10 Functions and Lambdas<a class="headerlink" href="#lec10-functions-and-lambdas" title="Permanent link">&para;</a></h1>
<h2 id="review-of-template-functions">Review of template functions<a class="headerlink" href="#review-of-template-functions" title="Permanent link">&para;</a></h2>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">InputIt</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">DataType</span><span class="o">&gt;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">count_occurrences</span><span class="p">(</span><span class="n">InputIt</span><span class="w"> </span><span class="n">begin</span><span class="p">,</span><span class="w"> </span><span class="n">InputIt</span><span class="w"> </span><span class="n">end</span><span class="p">,</span><span class="w"> </span><span class="n">DataType</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">begin</span><span class="p">;</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">end</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">iter</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
<span class="w"> </span><span class="p">}</span>
<span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
<span class="nl">Usage</span><span class="p">:</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Xadia&quot;</span><span class="p">;</span>
<span class="w">       </span><span class="n">count_occurrences</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">str</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="p">);</span>
</code></pre></div>
<p>Could we reuse this to find how many vowels are in ”Xadia”, or how  many odd numbers were in a std::vector?</p>
<h2 id="function-pointers-and-lambdas">Function Pointers and Lambdas<a class="headerlink" href="#function-pointers-and-lambdas" title="Permanent link">&para;</a></h2>
<h3 id="predicate-functions">Predicate Functions<a class="headerlink" href="#predicate-functions" title="Permanent link">&para;</a></h3>
<blockquote>
<p>Any function that returns a boolean is a predicate!</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="c1">//Unary Predicate</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">isLowercaseA</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">isVowel</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">vowels</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;aeiou&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">vowels</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//Binary Predicate</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">isMoreThan</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">num</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">limit</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">limit</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">isDivisibleBy</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="function-pointers-for-generalization">Function Pointers for generalization<a class="headerlink" href="#function-pointers-for-generalization" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">InputIt</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">UnaryPred</span><span class="o">&gt;</span><span class="c1">//no typename DataType</span>
<span class="kt">int</span><span class="w"> </span><span class="n">count_occurrences</span><span class="p">(</span><span class="n">InputIt</span><span class="w"> </span><span class="n">begin</span><span class="p">,</span><span class="w"> </span><span class="n">InputIt</span><span class="w"> </span><span class="n">end</span><span class="p">,</span><span class="w"> </span><span class="n">UnaryPred</span><span class="w"> </span><span class="n">pred</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="c1">//add UnaryPred pred</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">begin</span><span class="p">;</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">end</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">iter</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">))</span><span class="w"> </span><span class="n">count</span><span class="o">++</span><span class="p">;</span><span class="c1">//no *iter == val</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">isVowel</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">vowels</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;aeiou&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">vowels</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span><span class="p">;</span>
<span class="p">}</span>
<span class="nl">Usage</span><span class="p">:</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Xadia&quot;</span><span class="p">;</span>
<span class="w">       </span><span class="n">count_occurrences</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">str</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">isVowel</span><span class="p">);</span>
</code></pre></div>
<p><strong>isVowel</strong> is a pointer, just like <code>Node *</code> or <code>char *</code>! It’s called a “function pointer”,  and can be treated like a variable.</p>
<p>Function pointers don’t  generalize well. </p>
<h3 id="lambdas">Lambdas<a class="headerlink" href="#lambdas" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">auto</span><span class="w"> </span><span class="n">var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">capture</span><span class="o">-</span><span class="n">clause</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">param</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">};</span>
<span class="c1">//Capture Clause: Outside variables your function uses</span>
<span class="c1">//Parameters: You can use auto in lambda parameters!</span>
</code></pre></div>
<p><strong>capture clause</strong></p>
<div class="highlight"><pre><span></span><code><span class="p">[]</span><span class="w"> </span><span class="c1">// captures nothing</span>
<span class="p">[</span><span class="n">limit</span><span class="p">]</span><span class="w"> </span><span class="c1">// captures lower by value</span>
<span class="p">[</span><span class="o">&amp;</span><span class="n">limit</span><span class="p">]</span><span class="w"> </span><span class="c1">// captures lower by reference</span>
<span class="p">[</span><span class="o">&amp;</span><span class="n">limit</span><span class="p">,</span><span class="w"> </span><span class="n">upper</span><span class="p">]</span><span class="w"> </span><span class="c1">// captures lower by reference, higher by value</span>
<span class="p">[</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="n">limit</span><span class="p">]</span><span class="w"> </span><span class="c1">// captures everything except lower by reference</span>
<span class="p">[</span><span class="o">&amp;</span><span class="p">]</span><span class="w"> </span><span class="c1">// captures everything by reference</span>
<span class="p">[</span><span class="o">=</span><span class="p">]</span><span class="w"> </span><span class="c1">// captures everything by value</span>
<span class="k">auto</span><span class="w"> </span><span class="n">printNum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
<span class="n">printNum</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w"> </span><span class="c1">// 5</span>
<span class="kt">int</span><span class="w"> </span><span class="n">limit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">isMoreThan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">limit</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">limit</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
<span class="n">isMoreThan</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span><span class="w"> </span><span class="c1">// true</span>
<span class="n">limit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">;</span>
<span class="n">isMoreThan</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
<span class="kt">int</span><span class="w"> </span><span class="n">upper</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">setUpper</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="n">upper</span><span class="p">]</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">upper</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
</code></pre></div>
<p><strong>Solution</strong></p>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">InputIt</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">UniPred</span><span class="o">&gt;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">count_occurrences</span><span class="p">(</span><span class="n">InputIt</span><span class="w"> </span><span class="n">begin</span><span class="p">,</span><span class="w"> </span><span class="n">InputIt</span><span class="w"> </span><span class="n">end</span><span class="p">,</span><span class="w"> </span><span class="n">UniPred</span><span class="w"> </span><span class="n">pred</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">begin</span><span class="p">;</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">end</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">iter</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">))</span><span class="w"> </span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
<span class="nl">Usage</span><span class="p">:</span>
<span class="kt">int</span><span class="w"> </span><span class="n">limit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">isMoreThan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">limit</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">limit</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nums</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="p">,</span><span class="mi">13</span><span class="p">};</span>
<span class="n">count_occurrences</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">isMoreThan</span><span class="p">);</span>
</code></pre></div>
<p><strong>what really are they</strong></p>
<ul>
<li>Lambdas are cheap, but copying them may not be.</li>
<li>Use lambdas when you need a short function, or one with read/write  access to local variables</li>
<li>Use function pointers for longer logic and for overloading</li>
<li>We use “auto” because type is figured out in compile time</li>
</ul>
<h3 id="functors-and-closures">Functors and Closures<a class="headerlink" href="#functors-and-closures" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">functor</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="k">operator</span><span class="p">()</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// parameters and function body</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">arg</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">num</span><span class="p">;</span><span class="w"> </span><span class="c1">// capture clause</span>
<span class="p">};</span>
<span class="kt">int</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">lambda</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="n">num</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">arg</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
<span class="n">lambda</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</code></pre></div>
<ul>
<li>A functor is any class that provides an implementation of operator().</li>
<li>Lambdas are essentially syntactic sugar for creating a functor.</li>
<li>If lambdas are functor classes, then “closures” are instances of those classes.</li>
<li>At runtime, closures are generated as instances of lambda classes.</li>
</ul>
<p>How do functors, lambdas, and function pointers relate?</p>
<p><strong>Answer:</strong>  standard function, std::function&lt;…&gt;, is the one to rule them all — it’s  the overarching type for anything callable in C++. Functors, lambdas, and  function pointers can all be casted to standard functions</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">functionPointer</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">num</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">arg</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// or</span>
<span class="kt">int</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">lambda</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="n">num</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">arg</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
<span class="n">lambda</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w"> </span><span class="c1">// num = 5;</span>
<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lambda</span><span class="p">;</span>
</code></pre></div>
<p>We could cast either functionPointer or lambda to func, as both of them  have a void return signature and take in one integer parameter.</p>
<h2 id="introducing-stl-algorithms">Introducing STL Algorithms<a class="headerlink" href="#introducing-stl-algorithms" title="Permanent link">&para;</a></h2>
<blockquote>
<p>A collection of completely generic functions written by C++ devs</p>
</blockquote>
<p><code>#include &lt;algorithm&gt;</code>:  </p>
<p>sort · reverse · min_element · max_element ·  binary_search · stable_partition · find · find_if · count_if · copy · transform · insert · for_each · etc.!</p>
<h1 id="lec11-operator-overloading">Lec11 Operator Overloading<a class="headerlink" href="#lec11-operator-overloading" title="Permanent link">&para;</a></h1>
<blockquote>
<p>Redefining what operators mean</p>
</blockquote>
<h2 id="function-overloading">Function Overloading<a class="headerlink" href="#function-overloading" title="Permanent link">&para;</a></h2>
<p>Allow for calling the same function with different parameters:</p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">sum</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">double</span><span class="w"> </span><span class="nf">sum</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// usage:</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="mf">1.5</span><span class="p">,</span><span class="w"> </span><span class="mf">2.4</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
</code></pre></div>
<h2 id="operator-overloading">Operator Overloading<a class="headerlink" href="#operator-overloading" title="Permanent link">&para;</a></h2>
<p><code>\+ - * / % ^ &amp; | ~ ! , = &lt; &gt; &lt;= &gt;=  ++ -- &lt;&lt; &gt;&gt; == != &amp;&amp; || += -= *=  /= %= ^= &amp;= |= &lt;&lt;= &gt;&gt;= [] () -&gt;  -&gt;* new new[] delete delete[]</code></p>
<div class="highlight"><pre><span></span><code><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">before</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// a, b defined earlier</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Time a is before Time b&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//Overloading</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Time a is before Time b&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="two-ways-to-overload-operators">Two ways to overload operators<a class="headerlink" href="#two-ways-to-overload-operators" title="Permanent link">&para;</a></h2>
<h3 id="member-functions">Member Functions<a class="headerlink" href="#member-functions" title="Permanent link">&para;</a></h3>
<p>Add a function called operator __ to your class:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Time</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Time</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="c1">//rhs = Right Hand Side</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Time</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// unary, no arguments</span>
<span class="p">}</span>
<span class="c1">//lhs (left hand side) of each operator is this.</span>
</code></pre></div>
<ul>
<li>Call the function on the left hand side of the expression (this) </li>
<li>Binary operators (5 + 2, "a" &lt; "b"): accept the right hand side (&amp; rhs) as an argument(参数). </li>
<li>Unary operators (~a, !b): don't take any arguments</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Time</span><span class="w"> </span><span class="p">{</span>
<span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Time</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">hours</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">hours</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">hours</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">hours</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// compare minutes, seconds...</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="n">Time</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="c1">// do something;</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>Operators can only be called on the left hand side</li>
<li>What if we can't control what's on the left hand side of the operation?</li>
<li>e.g. if we want to compare a double and a Fraction</li>
</ul>
<h3 id="non-member-functions">Non-Member Functions<a class="headerlink" href="#non-member-functions" title="Permanent link">&para;</a></h3>
<p>Add a function called operator __ outside of your class:</p>
<div class="highlight"><pre><span></span><code><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Time</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Time</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">);</span>
<span class="n">Time</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Time</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Time</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">);</span>
<span class="n">Time</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Time</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Time</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">);</span>
<span class="n">Time</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Time</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Time</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">);</span>
</code></pre></div>
<p>Instead of taking only rhs, it takes both the left hand side and right hand side!</p>
<p>The STL prefers using non-member functions for operator overloading:  </p>
<ol>
<li>allows the LHS to be a non-class type (e.g. double &lt; Fraction)</li>
<li>allows us to overload operations with a LHS class that we don't own</li>
</ol>
<p>You may be wondering how non-member functions can access private member variables:</p>
<p><strong>The answer</strong>: friends!</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Time</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// core member functions omitted for brevity</span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">friend</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Time</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Time</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">);</span>
<span class="w">    </span><span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">hours</span><span class="p">,</span><span class="w"> </span><span class="n">minutes</span><span class="p">,</span><span class="w"> </span><span class="n">seconds</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Time</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Time</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">lhs</span><span class="p">.</span><span class="n">hours</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">hours</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">lhs</span><span class="p">.</span><span class="n">minutes</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">minutes</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">lhs</span><span class="p">.</span><span class="n">seconds</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">seconds</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="-operator-overloading">&lt;&lt; Operator Overloading<a class="headerlink" href="#-operator-overloading" title="Permanent link">&para;</a></h3>
<p>We can use &lt;&lt; to output something to an std::ostream&amp;:</p>
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Time</span><span class="o">&amp;</span><span class="w"> </span><span class="n">time</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">out</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">time</span><span class="p">.</span><span class="n">hours</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;:&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">time</span><span class="p">.</span><span class="n">minutes</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;:&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">time</span><span class="p">.</span><span class="n">seconds</span><span class="p">;</span><span class="c1">// 1) print data to ostream </span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">out</span><span class="p">;</span><span class="w"> </span><span class="c1">// 2) return original ostream </span>
<span class="p">}</span>
<span class="c1">// in time.h -- friend declaration allows access to private attrs </span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">friend</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Time</span><span class="o">&amp;</span><span class="w"> </span><span class="n">time</span><span class="p">);</span>
<span class="c1">// now we can do this! </span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// 5:22:31</span>
</code></pre></div>
<p>This is how std::cout mixes types (and still works)!</p>
<div class="highlight"><pre><span></span><code><span class="c1">//Since these two methods are implemented in the STL</span>
<span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">s</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="c1">//then</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;test&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="c1">// (cout &lt;&lt; &quot;test&quot;) &lt;&lt; 5;</span>
<span class="c1">//then</span>
<span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;test&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span>
<span class="c1">//then</span>
<span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span>
<span class="c1">//then</span>
<span class="n">cout</span><span class="p">;</span>
</code></pre></div>
<p><strong>Don't overuse operator overloading!</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1">//Confusing</span>
<span class="n">MyString</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="s">&quot;opossum&quot;</span><span class="p">);</span>
<span class="n">MyString</span><span class="w"> </span><span class="n">b</span><span class="p">(</span><span class="s">&quot;quokka&quot;</span><span class="p">);</span>
<span class="n">MyString</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"> </span><span class="c1">// what does this even mean??</span>

<span class="c1">//Great!</span>
<span class="n">MyString</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="s">&quot;opossum&quot;</span><span class="p">);</span>
<span class="n">MyString</span><span class="w"> </span><span class="n">b</span><span class="p">(</span><span class="s">&quot;quokka&quot;</span><span class="p">);</span>
<span class="n">MyString</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">charsInCommon</span><span class="p">(</span><span class="n">b</span><span class="p">);</span><span class="w"> </span><span class="c1">// much better!</span>
</code></pre></div>
<h2 id="rules-of-operator-overloading">Rules of Operator Overloading<a class="headerlink" href="#rules-of-operator-overloading" title="Permanent link">&para;</a></h2>
<ol>
<li>Meaning should be obvious when you see it</li>
<li>Should be reasonably similar to corresponding arithmetic operations</li>
<li>Don't define <code>+</code> to mean set subtraction!</li>
<li>When the meaning isn't obvious, give it a normal name instead</li>
</ol>
<h1 id="lec12-special-member-function">Lec12 Special Member Function<a class="headerlink" href="#lec12-special-member-function" title="Permanent link">&para;</a></h1>
<h2 id="special-member-functions-smfs">Special Member Functions (SMFs)<a class="headerlink" href="#special-member-functions-smfs" title="Permanent link">&para;</a></h2>
<p>These functions are generated only when they're called (and before any  are explicitly defined by you):</p>
<ul>
<li>Default Constructor</li>
<li>Copy Constructor</li>
<li>Copy Assignment Operator</li>
<li>Destructor</li>
<li>Move Constructor</li>
<li>Move Assignment Operator</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Widget</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">        </span><span class="n">Widget</span><span class="p">();</span><span class="w"> </span><span class="c1">// default constructor</span>
<span class="w">        </span><span class="n">Widget</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Widget</span><span class="o">&amp;</span><span class="w"> </span><span class="n">w</span><span class="p">);</span><span class="w"> </span><span class="c1">// copy constructor</span>
<span class="w">        </span><span class="n">Widget</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Widget</span><span class="o">&amp;</span><span class="w"> </span><span class="n">w</span><span class="p">);</span><span class="w"> </span><span class="c1">// copy assignment operator</span>
<span class="w">        </span><span class="o">~</span><span class="n">Widget</span><span class="p">();</span><span class="w"> </span><span class="c1">// destructor</span>
<span class="w">        </span><span class="n">Widget</span><span class="w"> </span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">);</span><span class="w"> </span><span class="c1">// move constructor</span>
<span class="w">        </span><span class="n">Widget</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">);</span><span class="w"> </span><span class="c1">// move assignment operator</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>Default Constructor</li>
<li>object is created with no  parameters</li>
<li>constructor also has no parameters</li>
<li>all SMFs are public and inline function, meaning that wherever  it's used is replaced with the  generated code in the function</li>
<li>Copy Constructor</li>
<li>another type of constructor that creates an instance of a class</li>
<li>constructs a member-wise copy of  an object (deep copy)</li>
<li>Copy Assignment Operator</li>
<li>very similar to copy constructor,  except called when trying to set  one object equal to another  e.g. w1 = w2;</li>
<li>Destructor</li>
<li>called whenever object goes out  of scope</li>
<li>can be used for deallocating  member variables and avoiding  memory leaks</li>
<li>Move Constructor</li>
<li>Move Assignment Operator</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="c1">//Examples:</span>
<span class="k">using</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">func</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec1</span><span class="p">;</span><span class="c1">//Default constructor creates empty vector</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec2</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="c1">//Not a SMF - calls a constructor with parameters→{0,0,0}</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec3</span><span class="p">{</span><span class="mi">3</span><span class="p">};</span><span class="c1">//Also not a SMF, uses initializer_list</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec4</span><span class="p">();</span><span class="c1">//A function declaration! (C++&#39;s most vexing parse)</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec5</span><span class="p">(</span><span class="n">vec2</span><span class="p">};</span><span class="c1">//Copy constructor - vector created as copy of another</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec</span><span class="p">{};</span><span class="c1">//Also the default constructor</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec</span><span class="p">{</span><span class="n">vec3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">vec4</span><span class="p">};</span><span class="c1">//Copy constructor</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec4</span><span class="p">;</span><span class="c1">//Copy constructor - vec8 is newly constructor</span>
<span class="w">    </span><span class="n">vec8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec2</span><span class="p">;</span><span class="c1">//Copy assignment - vec8 is an existing object</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">vec8</span><span class="p">;</span><span class="c1">//Copy constructor: copies vec8 to location outside of func</span>
<span class="p">}</span><span class="c1">//Destructors on all values (except return value) are called</span>
</code></pre></div>
<h2 id="copy-constructors-and-copy-assignment-operators">Copy Constructors and Copy  Assignment Operators<a class="headerlink" href="#copy-constructors-and-copy-assignment-operators" title="Permanent link">&para;</a></h2>
<h3 id="initializer-lists">initializer lists<a class="headerlink" href="#initializer-lists" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="c1">//members are first default constructed (declared to be their default values)</span>
<span class="w">    </span><span class="n">_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">_capacity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kInitialSize</span><span class="p">;</span>
<span class="w">    </span><span class="n">_elems</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">T</span><span class="p">[</span><span class="n">kInitialSize</span><span class="p">];</span><span class="c1">//Then each member is reassigned. This seems wasteful!</span>
<span class="p">}</span>
<span class="c1">//The technique below is called an initializer list</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="c1">//Directly construct each member with a starting value</span>
<span class="w">    </span><span class="n">_size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">_capacity</span><span class="p">(</span><span class="n">kInitialSize</span><span class="p">),</span>
<span class="w">    </span><span class="n">_elems</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">T</span><span class="p">[</span><span class="n">kInitialSize</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span>
</code></pre></div>
<ul>
<li>Prefer to use member initializer lists, which directly constructs each  member with a given value</li>
<li>Faster! Why construct, and then immediately reassign? </li>
<li>What if members are a non-assignable type (you'll see by the end of  lecture how this can be possible!)</li>
<li>Important clarification: you can use member initializer lists for ANY  constructor, even if it has parameters (and thus isn't an SMF)</li>
</ul>
<h3 id="why-arent-the-default-smfs-always-sufficient">Why aren't the default SMFs  always sufficient?<a class="headerlink" href="#why-arent-the-default-smfs-always-sufficient" title="Permanent link">&para;</a></h3>
<p>The default compiler-generated copy constructor and copy  assignment operator functions work by manually copying each member variable!</p>
<p>Moral of the story: in many cases, copying is not  as simple as copying each member variable!</p>
<div class="highlight"><pre><span></span><code><span class="c1">//the default copy constructor</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">vector</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">    </span><span class="n">_size</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">_size</span><span class="p">),</span>
<span class="w">    </span><span class="n">_capacity</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">_capacity</span><span class="p">),</span>
<span class="w">    </span><span class="n">_elems</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">_elems</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="p">}</span>

<span class="c1">//We can create a new array</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">vector</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">    </span><span class="n">_size</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">_size</span><span class="p">),</span>
<span class="w">    </span><span class="n">_capacity</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">_capacity</span><span class="p">),</span>
<span class="w">    </span><span class="n">_elems</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">_elems</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="n">_elems</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">T</span><span class="p">[</span><span class="n">other</span><span class="p">.</span><span class="n">_capacity</span><span class="p">];</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">_elems</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">_elems</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">_size</span><span class="p">,</span><span class="w"> </span><span class="n">_elems</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//Even better: let&#39;s move this to the initializer list</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">vector</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">    </span><span class="n">_size</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">_size</span><span class="p">),</span>
<span class="w">    </span><span class="n">_capacity</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">_capacity</span><span class="p">),</span>
<span class="w">    </span><span class="n">_elems</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">T</span><span class="p">[</span><span class="n">other</span><span class="p">.</span><span class="n">_capacity</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="c1">//We can move our reassignment of _elems up!</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">_elems</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">_elems</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">_size</span><span class="p">,</span><span class="w"> </span><span class="n">_elems</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="c1">//the default copy assignment operator</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="k">operator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">_size</span><span class="p">;</span>
<span class="w">    </span><span class="n">_capacity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">_capacity</span><span class="p">;</span>
<span class="w">    </span><span class="n">_elems</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">_elems</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//Attempt 1: Allocate a new array and copy over elements</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="k">operator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">_size</span><span class="p">;</span>
<span class="w">    </span><span class="n">_capacity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">_capacity</span><span class="p">;</span>
<span class="w">    </span><span class="n">_elems</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">T</span><span class="p">[</span><span class="n">other</span><span class="p">.</span><span class="n">_capacity</span><span class="p">];</span><span class="c1">//We&#39;ve lost access to the old value of _elems, and leaked the array that it pointed to!</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">_elems</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">_elems</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">_size</span><span class="p">,</span><span class="w"> </span><span class="n">_elems</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//Attempt 2: Deallocate the old array and make a new one</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="k">operator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">other</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">this</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span><span class="c1">//Also, be careful about self-reassignment!</span>
<span class="w">    </span><span class="n">_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">_size</span><span class="p">;</span>
<span class="w">    </span><span class="n">_capacity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">_capacity</span><span class="p">;</span>
<span class="w">    </span><span class="k">delete</span><span class="p">[]</span><span class="w"> </span><span class="n">_elems</span><span class="p">;</span>
<span class="w">    </span><span class="n">_elems</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">T</span><span class="p">[</span><span class="n">other</span><span class="p">.</span><span class="n">_capacity</span><span class="p">];</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">_elems</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">_elems</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">_size</span><span class="p">,</span><span class="w"> </span><span class="n">_elems</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span><span class="c1">//Remember to return a reference to the vector itself</span>
<span class="p">}</span>
</code></pre></div>
<p>Copy operations must perform these tasks:</p>
<ul>
<li>Copy constructor</li>
<li>Use initializer list to copy members  where simple copying does the  correct thing.<ul>
<li>int, other objects, etc</li>
</ul>
</li>
<li>Manually copy all members otherwise <ul>
<li>pointers to heap memory</li>
<li>non-copyable things</li>
</ul>
</li>
<li>Copy assignment</li>
<li>Clean up any resources in the existing object about to be overwritten</li>
<li>Copy members using direct  assignment when assignment works</li>
<li>Manually copy members where assignment does not work</li>
<li>You don't have to do these in this order</li>
</ul>
<p>Summary: Steps to follow for an assignment operator</p>
<ol>
<li>Check for self-assignment.</li>
<li>Make sure to free existing members if applicable.</li>
<li>Copy assign each automatically assignable member. </li>
<li>Manually copy all other members.</li>
<li>Return a reference to *this (that was just reassigned).</li>
</ol>
<h2 id="-delete-and--default">= delete and = default<a class="headerlink" href="#-delete-and--default" title="Permanent link">&para;</a></h2>
<div class="highlight"><pre><span></span><code><span class="c1">//Explicitly delete the copy member functions</span>
<span class="c1">//Adding = delete; after a function prototype tells C++ to not generate the corresponding SMF</span>
<span class="k">class</span><span class="w"> </span><span class="nc">PasswordManager</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">        </span><span class="n">PasswordManager</span><span class="p">();</span>
<span class="w">        </span><span class="n">PasswordManager</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">PasswordManager</span><span class="o">&amp;</span><span class="w"> </span><span class="n">pm</span><span class="p">);</span>
<span class="w">        </span><span class="o">~</span><span class="n">PasswordManager</span><span class="p">();</span>
<span class="w">        </span><span class="c1">// other methods ...</span>
<span class="w">        </span><span class="n">PasswordManager</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">PasswordManager</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delete</span><span class="p">;</span>
<span class="w">        </span><span class="n">PasswordManager</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">PasswordManager</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delete</span><span class="p">;</span>
<span class="w">    </span><span class="k">private</span><span class="o">:</span>
<span class="w">        </span><span class="c1">// other important members ...</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="c1">//Is there a way to keep, say, the default copy constructor if you write another constructor?</span>
<span class="c1">//Adding = default; after a function prototype tells C++ to still generate the default SMF, even if you&#39;re defining other SMFs</span>
<span class="k">class</span><span class="w"> </span><span class="nc">PasswordManager</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">        </span><span class="n">PasswordManager</span><span class="p">();</span>
<span class="w">        </span><span class="n">PasswordManager</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">PasswordManager</span><span class="o">&amp;</span><span class="w"> </span><span class="n">pm</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>
<span class="w">        </span><span class="o">~</span><span class="n">PasswordManager</span><span class="p">();</span>
<span class="w">        </span><span class="c1">// other methods ...</span>
<span class="w">        </span><span class="n">PasswordManager</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">PasswordManager</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delete</span><span class="p">;</span>
<span class="w">        </span><span class="n">PasswordManager</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">PasswordManager</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delete</span><span class="p">;</span>
<span class="w">    </span><span class="k">private</span><span class="o">:</span>
<span class="w">        </span><span class="c1">// other important members ...</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="rule-of-0-and-rule-of-3">Rule of 0 and Rule of 3<a class="headerlink" href="#rule-of-0-and-rule-of-3" title="Permanent link">&para;</a></h2>
<h3 id="rule-of-0">Rule of 0<a class="headerlink" href="#rule-of-0" title="Permanent link">&para;</a></h3>
<blockquote>
<p>If the default operations work, then don't define your own!</p>
</blockquote>
<p>When should you define your own SMFs</p>
<ul>
<li>When the default ones generated by the compiler won't work</li>
<li>Most common reason: there's a resource that our class uses that's not  stored inside of our class </li>
<li>e.g. dynamically allocated memory<ul>
<li>our class only stores the pointers to arrays, not the arrays in memory  itself</li>
</ul>
</li>
</ul>
<h3 id="rule-of-3-c-98">Rule of 3 (C++ 98)<a class="headerlink" href="#rule-of-3-c-98" title="Permanent link">&para;</a></h3>
<ul>
<li>If you explicitly define a copy constructor, copy assignment operator, or  destructor, you should define all three</li>
<li>What's the rationale?</li>
<li>If you're explicitly writing your own copy operation, you're controlling  certain resources manually</li>
<li>You should then manage the creation, use, and releasing of those  resources!</li>
</ul>
<p><strong>Recap of Special Member Functions (SMFs)</strong></p>
<ul>
<li>Default Constructor</li>
<li>Object created with no parameters, no member variables instantiated </li>
<li>Copy Constructor</li>
<li>Object created as a copy of existing object (member variable-wise) </li>
<li>Copy Assignment Operator</li>
<li>Existing object replaced as a copy of another existing object. </li>
<li>Destructor </li>
<li>Object destroyed when it is out of scope.</li>
</ul>
<p>Are these 4 enough?</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">StringTable</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">        </span><span class="n">StringTable</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>
<span class="w">        </span><span class="n">StringTable</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">StringTable</span><span class="o">&amp;</span><span class="w"> </span><span class="n">st</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="w">        </span><span class="c1">// functions for insertion, erasure, lookup, etc., </span>
<span class="w">        </span><span class="c1">// but no move/dtor functionality</span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">    </span><span class="k">private</span><span class="o">:</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">values</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="move-constructors-and-move-assignment-operators">Move constructors and move  assignment operators<a class="headerlink" href="#move-constructors-and-move-assignment-operators" title="Permanent link">&para;</a></h2>
<h3 id="move-operations-c11">Move Operations (C++11)<a class="headerlink" href="#move-operations-c11" title="Permanent link">&para;</a></h3>
<p>These functions are generated only when they're called (and before any are explicitly defined by you)</p>
<div class="highlight"><pre><span></span><code><span class="c1">//Allow for moving objects and std::move operations (rvalue refs)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Widget</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">        </span><span class="n">Widget</span><span class="p">();</span><span class="w"> </span><span class="c1">// default constructor</span>
<span class="w">        </span><span class="n">Widget</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Widget</span><span class="o">&amp;</span><span class="w"> </span><span class="n">w</span><span class="p">);</span><span class="w"> </span><span class="c1">// copy constructor</span>
<span class="w">        </span><span class="n">Widget</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Widget</span><span class="o">&amp;</span><span class="w"> </span><span class="n">w</span><span class="p">);</span><span class="w"> </span><span class="c1">// copy assignment operator</span>
<span class="w">        </span><span class="o">~</span><span class="n">Widget</span><span class="p">();</span><span class="w"> </span><span class="c1">// destructor</span>
<span class="w">        </span><span class="n">Widget</span><span class="w"> </span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">);</span><span class="w"> </span><span class="c1">// move constructor</span>
<span class="w">        </span><span class="n">Widget</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">);</span><span class="w"> </span><span class="c1">// move assignment operator</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>Move constructors and move assignment operators will perform  "memberwise moves"</li>
<li>Defining a copy constructor does not affect generation of a default copy  assignment operator, and vice versa</li>
<li>Defining a move assignment operator prevents generation of a move copy  constructor, and vice versa</li>
<li>Rationale: if the move assignment operator needs to be re-implemented,  there'd likely be a problem with the move constructor</li>
</ul>
<h3 id="some-nuances-to-move-operation-smfs">Some nuances to move operation SMFs<a class="headerlink" href="#some-nuances-to-move-operation-smfs" title="Permanent link">&para;</a></h3>
<ul>
<li>Move operations are generated for classes only if these things are true:</li>
<li>No copy operations are declared in the class </li>
<li>No move operations are declared in the class</li>
<li>No destructor is declared in the class<ul>
<li>Can get around all of these by using default:</li>
</ul>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="n">Widget</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>
<span class="n">Widget</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span><span class="w"> </span><span class="c1">// support moving</span>
<span class="n">Widget</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Widget</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>
<span class="n">Widget</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Widget</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span><span class="w"> </span><span class="c1">// support copying</span>
</code></pre></div>
<h1 id="lec13-move-semantics-in-c">Lec13 Move Semantics in C++<a class="headerlink" href="#lec13-move-semantics-in-c" title="Permanent link">&para;</a></h1>
<blockquote>
<p>l-values live until the end of the scope </p>
<p>r-values live until the end of the line</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="c1">//Find the r-values! (Only consider the items on the right of = signs)</span>
<span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="c1">//3 is an r-value</span>
<span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x02248837</span><span class="p">;</span><span class="w"> </span><span class="c1">//0x02248837 is an r-value</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v1</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">};</span><span class="w"> </span><span class="c1">//{1, 2, 3} is an r-value,v1 is an l-value</span>
<span class="k">auto</span><span class="w"> </span><span class="n">v4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">v2</span><span class="p">;</span><span class="w"> </span><span class="c1">//v1 + v2 is an r-value</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="c1">//v.size()is an r-value</span>
<span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="o">*</span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="c1">//4*i is an r-value, v1[1] is an l-value</span>
<span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="c1">//&amp;x is an r-value</span>
<span class="n">v1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">;</span><span class="w"> </span><span class="c1">//*ptr is an l-value</span>
<span class="n">MyClass</span><span class="w"> </span><span class="n">obj</span><span class="p">;</span><span class="w"> </span><span class="c1">//obj is an l-value</span>
<span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">obj</span><span class="p">.</span><span class="n">public_member_variable</span><span class="p">;</span><span class="w"> </span><span class="c1">//obj.public_member_variable is l-value</span>
</code></pre></div>
<h2 id="how-many-arrays-will-be-allocated-copied-and-destroyed-here">How many arrays will be allocated, copied and destroyed here?<a class="headerlink" href="#how-many-arrays-will-be-allocated-copied-and-destroyed-here" title="Permanent link">&para;</a></h2>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec</span><span class="p">;</span>
<span class="w">    </span><span class="n">vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_me_a_vec</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span><span class="w"> </span><span class="c1">// //make_me_a_vec(123) is an r-value</span>
<span class="p">}</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">make_me_a_vec</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">num</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">res</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">num</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">num</span><span class="o">%</span><span class="mi">10</span><span class="p">);</span>
<span class="w">        </span><span class="n">num</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>vec is created using the default constructor </li>
<li>make_me_a_vec creates a vector using the default constructor and returns it </li>
<li>vec is reassigned to a copy of that return value using copy assignment</li>
<li>copy assignment creates a new array and copies the contents of the old one </li>
<li>The original return value’s lifetime ends and it calls its destructor </li>
<li>vec’s lifetime ends and it calls its destructor</li>
</ul>
<h2 id="how-do-we-know-when-to-use-move-assignment-and-when-to-use-copy-assignment">How do we know when to use move assignment and  when to use copy assignment?<a class="headerlink" href="#how-do-we-know-when-to-use-move-assignment-and-when-to-use-copy-assignment" title="Permanent link">&para;</a></h2>
<p><strong>Answer</strong>: When the item on the right of the = is an  r-value we should use move assignment</p>
<p>Why? r-values are always about to die, so we can steal their resources</p>
<div class="highlight"><pre><span></span><code><span class="c1">//Examples</span>
<span class="c1">//Using move assignment</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec</span><span class="p">;</span>
<span class="w">    </span><span class="n">vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_me_a_vec</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span><span class="w"> </span>
<span class="p">}</span>
<span class="c1">//Using copy assignment</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="err">“</span><span class="n">hello</span><span class="err">”</span><span class="p">,</span><span class="w"> </span><span class="err">“</span><span class="n">world</span><span class="err">”</span><span class="p">}</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec1</span><span class="p">;</span>
<span class="w">    </span><span class="n">vec1</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="err">“</span><span class="n">Sure</span><span class="w"> </span><span class="n">hope</span><span class="w"> </span><span class="n">vec2</span><span class="w"> </span><span class="n">doesn</span><span class="err">’</span><span class="n">t</span><span class="w"> </span><span class="n">see</span><span class="w"> </span><span class="k">this</span><span class="o">!</span><span class="err">”</span><span class="p">)</span>
<span class="p">}</span><span class="w"> </span><span class="c1">//and vec2 never saw a thing</span>
</code></pre></div>
<h2 id="the-r-value-reference">the r-value reference<a class="headerlink" href="#the-r-value-reference" title="Permanent link">&para;</a></h2>
<blockquote>
<p>How to make two different assignment operators? Overload vector::operator= ! </p>
<p>How? Introducing… the r-value reference <code>&amp;&amp;</code></p>
<p>(This is different from the l-value reference &amp; you have see before) (it has one more ampersand)</p>
</blockquote>
<p><strong>Overloading with <code>&amp;&amp;</code></strong></p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">change</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="c1">//this will call version 2</span>
<span class="w">    </span><span class="n">change</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span><span class="w"> </span><span class="c1">//this will call version 1</span>
<span class="p">}</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">change</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">num</span><span class="p">){...}</span><span class="w"> </span><span class="c1">//version 1 takes r-values</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">change</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">num</span><span class="p">){...}</span><span class="w"> </span><span class="c1">//version 2 takes l-values</span>
<span class="c1">//num is a reference to vec</span>
</code></pre></div>
<h3 id="copy-assignment-and-move-assignment">Copy assignment and Move assignment<a class="headerlink" href="#copy-assignment-and-move-assignment" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="c1">//Copy assignment</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">other</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">this</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="n">_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">_size</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="n">_capacity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">_capacity</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="c1">//must copy entire array</span>
<span class="w">    </span><span class="k">delete</span><span class="p">[]</span><span class="w"> </span><span class="n">_elems</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="n">_elems</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">T</span><span class="p">[</span><span class="n">other</span><span class="p">.</span><span class="n">_capacity</span><span class="p">];</span><span class="w"> </span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">_elems</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">other</span><span class="p">.</span><span class="n">_elems</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">_size</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">_elems</span><span class="p">);</span><span class="w"> </span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//Move assignment</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">other</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">this</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="n">_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">_size</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="n">_capacity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">_capacity</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="c1">//we can steal the array</span>
<span class="w">    </span><span class="k">delete</span><span class="p">[]</span><span class="w"> </span><span class="n">_elems</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="n">_elems</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">_elems</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span><span class="w"> </span>
<span class="p">}</span>
<span class="c1">//This works</span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec</span><span class="p">;</span>
<span class="w">    </span><span class="n">vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_me_a_vec</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span><span class="w"> </span><span class="c1">//this will use move assignment</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="err">“</span><span class="n">hello</span><span class="err">”</span><span class="p">,</span><span class="w"> </span><span class="err">“</span><span class="n">world</span><span class="err">”</span><span class="p">}</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec1</span><span class="p">;</span><span class="w"> </span><span class="c1">//this will use copy assignment</span>
<span class="w">    </span><span class="n">vec1</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="err">“</span><span class="n">Sure</span><span class="w"> </span><span class="n">hope</span><span class="w"> </span><span class="n">vec2</span><span class="w"> </span><span class="n">doesn</span><span class="err">’</span><span class="n">t</span><span class="w"> </span><span class="n">see</span><span class="w"> </span><span class="k">this</span><span class="o">!</span><span class="err">”</span><span class="p">)</span>
<span class="p">}</span><span class="w"> </span>
</code></pre></div>
<p><strong>The compiler will pick which vector::operator= to use based  on whether the RHS is an l-value or an r-value</strong></p>
<h3 id="can-we-make-it-even-better">Can we make it even better?<a class="headerlink" href="#can-we-make-it-even-better" title="Permanent link">&para;</a></h3>
<p>In the move assignment above, these are also making copies (using int/ptr copy assignment)</p>
<div class="highlight"><pre><span></span><code><span class="n">_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">_size</span><span class="p">;</span><span class="w"> </span>
<span class="n">_capacity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">_capacity</span><span class="p">;</span><span class="w"> </span>
<span class="n">_elems</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">_elems</span><span class="p">;</span>
</code></pre></div>
<p>We can force move assignment  rather than copy assignment of these ints by using std::move</p>
<div class="highlight"><pre><span></span><code><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">other</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">this</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="n">_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">_size</span><span class="p">);</span><span class="w"> </span>
<span class="w">    </span><span class="n">_capacity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">_capacity</span><span class="p">);</span><span class="w"> </span>
<span class="w">    </span><span class="c1">//we can steal the array</span>
<span class="w">    </span><span class="k">delete</span><span class="p">[]</span><span class="w"> </span><span class="n">_elems</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="n">_elems</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">_elems</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span><span class="w"> </span>
<span class="p">}</span>
</code></pre></div>
<p>The compiler will pick which vector::operator= to use based on whether the RHS is an l-value or an r-value</p>
<h3 id="constructor">Constructor<a class="headerlink" href="#constructor" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="c1">//How about this</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec</span><span class="p">;</span>
<span class="w">    </span><span class="n">vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_me_a_vec</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span><span class="w"> </span><span class="c1">//this will use move assignment</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="err">“</span><span class="n">hello</span><span class="err">”</span><span class="p">,</span><span class="w"> </span><span class="err">“</span><span class="n">world</span><span class="err">”</span><span class="p">}</span><span class="w"> </span><span class="c1">//this should use move </span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec1</span><span class="p">;</span><span class="w"> </span><span class="c1">//this will use copy construction</span>
<span class="w">    </span><span class="n">vec1</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="err">“</span><span class="n">Sure</span><span class="w"> </span><span class="n">hope</span><span class="w"> </span><span class="n">vec2</span><span class="w"> </span><span class="n">doesn</span><span class="err">’</span><span class="n">t</span><span class="w"> </span><span class="n">see</span><span class="w"> </span><span class="k">this</span><span class="o">!</span><span class="err">”</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="c1">//copy constructor</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">other</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">this</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="n">_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">_size</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="n">_capacity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">_capacity</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="c1">//must copy entire array</span>
<span class="w">    </span><span class="k">delete</span><span class="p">[]</span><span class="w"> </span><span class="n">_elems</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="n">_elems</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">T</span><span class="p">[</span><span class="n">other</span><span class="p">.</span><span class="n">_capacity</span><span class="p">];</span><span class="w"> </span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">_elems</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">_elems</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">_size</span><span class="p">,</span><span class="w"> </span><span class="n">_elems</span><span class="p">);</span><span class="w"> </span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span><span class="w"> </span>
<span class="p">}</span>
<span class="c1">//move constructor</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">other</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">this</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="w">    </span><span class="n">_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">_size</span><span class="p">);</span><span class="w"> </span>
<span class="w">    </span><span class="n">_capacity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">_capacity</span><span class="p">);</span><span class="w"> </span>
<span class="w">    </span><span class="c1">//we can steal the array</span>
<span class="w">    </span><span class="k">delete</span><span class="p">[]</span><span class="w"> </span><span class="n">_elems</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="n">_elems</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">_elems</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>Where else should we use std::move?</p>
<p><strong>Answer</strong>: </p>
<ol>
<li>Wherever we take in a const &amp; parameter in a class member function and assign it  to something else in our function</li>
<li>Don’t use std::move outside of class  definitions, never use it in application code!</li>
</ol>
<h3 id="vectorpush_back">vector::push_back<a class="headerlink" href="#vectorpush_back" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="c1">//Copy push_back </span>
<span class="kt">void</span><span class="w"> </span><span class="nf">push_back</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">element</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">elems</span><span class="p">[</span><span class="n">_size</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">element</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="c1">//this is copy assignment </span>
<span class="p">}</span>
<span class="c1">//Move push_back</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">push_back</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">element</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">elems</span><span class="p">[</span><span class="n">_size</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">element</span><span class="p">);</span><span class="w"> </span>
<span class="w">    </span><span class="c1">//this forces T’s move assignment </span>
<span class="p">}</span>
</code></pre></div>
<h3 id="be-careful-with-stdmove">Be careful with std::move<a class="headerlink" href="#be-careful-with-stdmove" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="err">“</span><span class="n">hello</span><span class="err">”</span><span class="p">,</span><span class="w"> </span><span class="err">“</span><span class="n">world</span><span class="err">”</span><span class="p">}</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">vec1</span><span class="p">);</span>
<span class="w">    </span><span class="n">vec1</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="err">“</span><span class="n">Sure</span><span class="w"> </span><span class="n">hope</span><span class="w"> </span><span class="n">vec2</span><span class="w"> </span><span class="n">doesn</span><span class="err">’</span><span class="n">t</span><span class="w"> </span><span class="n">see</span><span class="w"> </span><span class="k">this</span><span class="o">!</span><span class="err">”</span><span class="p">)</span><span class="c1">//wrong!!!</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>After a variable is moved via std::move, it should never be used until it is  reassigned to a new variable!</li>
<li>The C++ compiler might warn you about this mistake, but the code above compiles!</li>
</ul>
<h2 id="tldr-move-semantics">TLDR: Move Semantics<a class="headerlink" href="#tldr-move-semantics" title="Permanent link">&para;</a></h2>
<ul>
<li>If your class has copy constructor and copy assignment defined, you should also define a move constructor and move assignment</li>
<li>Define these by overloading your copy constructor and assignment to be  defined for Type&amp;&amp; other as well as Type&amp; other </li>
<li>Use std::move to force the use of other types’ move assignments and  constructors </li>
<li>All std::move(x) does is cast x as an rvalue </li>
<li>Be wary of std::move(x) in main function code</li>
</ul>
<h2 id="bonus-stdmove-and-raii">Bonus: std::move and RAII<a class="headerlink" href="#bonus-stdmove-and-raii" title="Permanent link">&para;</a></h2>
<ul>
<li>Recall: RAII means all resources required by an object are acquired in its constructor and destroyed in its destructor </li>
<li>To be consistent with RAII, you should have no half-ready resources, such as a  vector whose underlying array has been deallocated</li>
</ul>
<p>Is std::move consistent with RAII?</p>
<ul>
<li>I say NO! </li>
<li>This is a sticky language design flaw, C++ has a lot of those! </li>
</ul>
<h1 id="lec14-type-safety-and-stdoptional">Lec14 Type Safety and <code>std::optional</code><a class="headerlink" href="#lec14-type-safety-and-stdoptional" title="Permanent link">&para;</a></h1>
<h2 id="recap-const-correctness">Recap: Const-Correctness<a class="headerlink" href="#recap-const-correctness" title="Permanent link">&para;</a></h2>
<ul>
<li>We pass big pieces of data by reference into helper functions  by to avoid making copies of that data</li>
<li>If this function accidentally or sneakily changes that piece of  data, it can lead to hard to find bugs! </li>
<li><strong>Solution</strong>: mark those reference parameters const to  guarantee they won’t be changed in the function!</li>
</ul>
<h2 id="how-does-the-compiler-know-when-its-safe-to-call-member-functions-of-const-variables">How does the compiler know when it’s safe to call  member functions of const variables?<a class="headerlink" href="#how-does-the-compiler-know-when-its-safe-to-call-member-functions-of-const-variables" title="Permanent link">&para;</a></h2>
<blockquote>
<p>const-interface: All member functions marked const in a class definition. Objects of  type const ClassName may only use the const-interface.</p>
</blockquote>
<p><strong>RealVector’s const-interface</strong></p>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">ValueType</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">RealVector</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">iterator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ValueType</span><span class="o">*</span><span class="p">;</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">const_</span><span class="w"> </span><span class="n">iterator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ValueType</span><span class="o">*</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/*...*/</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">size</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">empty</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/*...*/</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">push_back</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ValueType</span><span class="o">&amp;</span><span class="w"> </span><span class="n">elem</span><span class="p">);</span>
<span class="w">    </span><span class="n">iterator</span><span class="w"> </span><span class="nf">begin</span><span class="p">();</span>
<span class="w">    </span><span class="n">iterator</span><span class="w"> </span><span class="nf">end</span><span class="p">();</span>
<span class="w">    </span><span class="n">const_iterator</span><span class="w"> </span><span class="nf">cbegin</span><span class="p">()</span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="n">const_iterator</span><span class="w"> </span><span class="nf">cend</span><span class="p">()</span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/*...*/</span>
<span class="p">}</span>
</code></pre></div>
<p>Key Idea: Sometimes less functionality is better functionality</p>
<ul>
<li>Technically, adding a const-interface only limits what RealVector objects marked const can do </li>
<li>Using types to enforce assumptions we make about function calls help us prevent programmer errors! </li>
</ul>
<h2 id="type-safety">Type Safety<a class="headerlink" href="#type-safety" title="Permanent link">&para;</a></h2>
<blockquote>
<p>Type Safety: The extent to which a language prevents typing errors.<strong>guarantees the behavior  of programs.</strong></p>
</blockquote>
<p>What does this code do?</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">removeOddsFromEnd</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">vec</span><span class="p">){</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">back</span><span class="p">()</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">){</span>
<span class="w">        </span><span class="n">vec</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="c1">//What happens when input is {} ?</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="c1">//One solution</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">removeOddsFromEnd</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">vec</span><span class="p">){</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">vec</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">back</span><span class="p">()</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">){</span>
<span class="w">        </span><span class="n">vec</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="c1">//Key idea: it is the programmers job to enforce the precondition that vec be non-empty, otherwise we get undefined behavior!</span>
</code></pre></div>
<p>There may or may not be a “last element” in vec. How can vec.back() have deterministic  behavior in either case?</p>
<p><strong>The problem</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">valueType</span><span class="o">&amp;</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">valueType</span><span class="o">&gt;::</span><span class="n">back</span><span class="p">(){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">begin</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//Dereferencing a pointer without verifying it points to real memory is undefined behavior!</span>

<span class="n">valueType</span><span class="o">&amp;</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">valueType</span><span class="o">&gt;::</span><span class="n">back</span><span class="p">(){</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">out_of_range</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">begin</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//Now, we will at least reliably error and stop the program or return the last element whenever back() is called</span>
</code></pre></div>
<blockquote>
<p>Type Safety: The extent to  which a <strong>function signature</strong> guarantees the  behavior of a <strong>function</strong>.</p>
</blockquote>
<p><strong>The problem</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1">//back() is promising to return something of type valueType when its possible no such value exists!</span>
<span class="n">valueType</span><span class="o">&amp;</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">valueType</span><span class="o">&gt;::</span><span class="n">back</span><span class="p">(){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">begin</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//A first solution?</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">valueType</span><span class="o">&amp;&gt;</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">valueType</span><span class="o">&gt;::</span><span class="n">back</span><span class="p">(){</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">empty</span><span class="p">()){</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="n">valueType</span><span class="p">()};</span><span class="c1">//valueType may not have a default constructor</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">begin</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)};</span>
<span class="p">}</span><span class="c1">//Even if it does, calling constructors is expensive</span>

<span class="c1">//So, what should back() return?</span>
<span class="o">???</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">valueType</span><span class="o">&gt;::</span><span class="n">back</span><span class="p">(){</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">empty</span><span class="p">()){</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">??</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">begin</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span><span class="c1">//Introducing std::optional</span>
</code></pre></div>
<h2 id="stdoptional">std::optional<a class="headerlink" href="#stdoptional" title="Permanent link">&para;</a></h2>
<p><strong>What is <code>std::optional&lt;T&gt;</code>?</strong></p>
<p><code>std::optional</code> is a template class which will either contain a value of type T or contain nothing (expressed as <code>nullopt</code>)</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">num1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"> </span><span class="c1">//num1 does not have a value</span>
<span class="w">    </span><span class="n">num1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">//now it does!</span>
<span class="w">    </span><span class="n">num1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">;</span><span class="w"> </span><span class="c1">//now it doesn&#39;t anymore</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>What if back() returned an optional?</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">valueType</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">valueType</span><span class="o">&gt;::</span><span class="n">back</span><span class="p">(){</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">empty</span><span class="p">()){</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">{};</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">begin</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>std::optional interface</strong></p>
<ul>
<li><code>.value()</code> returns the contained value or throws bad_optional_access error </li>
<li><code>.value_or(valueType val)</code> returns the contained value or default value, parameter val</li>
<li><code>.has_value()</code> returns true if contained value exists, false otherwise</li>
</ul>
<p><strong>Checking if an optional has value</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lookupStudent</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">){</span><span class="c1">//something}</span>
<span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lookupStudent</span><span class="p">(</span><span class="err">“</span><span class="n">Keith</span><span class="err">”</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">student</span><span class="p">){</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">output</span><span class="p">.</span><span class="n">value</span><span class="p">().</span><span class="n">name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="err">“</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="err">“</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">output</span><span class="p">.</span><span class="n">value</span><span class="p">().</span><span class="n">state</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="err">“</span><span class="n">No</span><span class="w"> </span><span class="n">student</span><span class="w"> </span><span class="n">found</span><span class="err">”</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>So we have perfect solutions</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">removeOddsFromEnd</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">vec</span><span class="p">){</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">has_value</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">value</span><span class="p">()</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">){</span>
<span class="w">        </span><span class="n">vec</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="c1">//Below totally hacky, but totally works, but don&#39;t do this!</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">removeOddsFromEnd</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">vec</span><span class="p">){</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">value_or</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">){</span>
<span class="w">        </span><span class="n">vec</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>Recap: The problem with std::vector::back()</strong></p>
<ul>
<li>Why is it so easy to accidentally call back() on empty  vectors if the outcome is so dangerous? </li>
<li>The function signature gives us a false promise! </li>
<li>Promises to return an something of type valueType </li>
<li>But in reality, there either may or may not be a “last element”  in a vector</li>
</ul>
<p><strong>std::optional “monadic” interface (C++23 sneak peek!)</strong></p>
<ul>
<li><code>.and_then(function f)</code> returns the result of calling f(value) if contained value exists,  otherwise null_opt (f must return optional) </li>
<li><code>.transform(function f)</code>returns the result of calling f(value) if contained value exists,  otherwise null_opt (f must return optional) </li>
<li><code>.or_else(function f)</code> returns value if it exists, otherwise returns result of calling f</li>
</ul>
<p><strong>Recall: Design Philosophy of C++</strong></p>
<ul>
<li>Only add features if they solve an actual problem</li>
<li>Programmers should be free to choose their own style</li>
<li>Compartmentalization is key </li>
<li>Allow the programmer full control if they want it</li>
<li>Don’t sacrifice performance except as a last resort</li>
<li>Enforce safety at compile time whenever possible</li>
</ul>
<h2 id="recap-type-safety-and-stdoptional">Recap: Type Safety and std::optional<a class="headerlink" href="#recap-type-safety-and-stdoptional" title="Permanent link">&para;</a></h2>
<ul>
<li>You can guarantee the behavior of your programs by using a strict type  system! </li>
<li>std::optional is a tool that could make this happen: you can return either a  value or nothing</li>
<li>.has_value() </li>
<li>.value_or() </li>
<li>.value() </li>
<li>This can be unwieldy and slow, so cpp doesn’t use optionals in most stl data  structures</li>
<li>Many languages, however, do! </li>
<li>The ball is in your court!</li>
</ul>
<blockquote>
<p>“Well typed programs cannot go wrong.” </p>
<ul>
<li>Robert Milner (very  important and good CS dude)</li>
</ul>
</blockquote>
<h1 id="lec15-raii-smart-pointers-and-c-project-building">Lec15 RAII, Smart Pointers, and C++  Project Building<a class="headerlink" href="#lec15-raii-smart-pointers-and-c-project-building" title="Permanent link">&para;</a></h1>
<h2 id="exceptions---why-care">Exceptions - Why care?<a class="headerlink" href="#exceptions---why-care" title="Permanent link">&para;</a></h2>
<h3 id="how-many-code-paths-are-in-this-function">How many code paths are in this function?<a class="headerlink" href="#how-many-code-paths-are-in-this-function" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="n">string</span><span class="w"> </span><span class="nf">get_name_and_print_sweet_tooth</span><span class="p">(</span><span class="n">Person</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">favorite_food</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;chocolate&quot;</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">favorite_drink</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;milkshake&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">last</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; has a sweet tooth!&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">last</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>Code Path 1 - favors neither chocolate nor milkshakes</li>
<li>Code Path 2 - favors milkshakes</li>
<li>Code Path 3 - favors chocolate (and possibly milkshakes)</li>
</ul>
<p>Are there any more code paths?</p>
<h3 id="hint-exceptions">Hint: Exceptions<a class="headerlink" href="#hint-exceptions" title="Permanent link">&para;</a></h3>
<ul>
<li>
<p>Exceptions are ways to signal that something has gone wrong during run-time</p>
</li>
<li>
<p>Exceptions are "thrown" and can crash the program, but can be "caught" to  avoid this</p>
</li>
</ul>
<h3 id="hidden-code-paths">Hidden Code Paths<a class="headerlink" href="#hidden-code-paths" title="Permanent link">&para;</a></h3>
<p>There are (at least) 23 code paths in the code before! </p>
<ul>
<li>(1) copy constructor of Person parameter may throw</li>
<li>(5) constructor of temp string may throw </li>
<li>(6) call to favorite_food, favorite_drink, first (2), last (2), may throw</li>
<li>(10) operators may be user-overloaded, thus may throw</li>
<li>(1) copy constructor of string for return value may throw</li>
</ul>
<h3 id="what-could-go-wrong-here">What could go wrong here?<a class="headerlink" href="#what-could-go-wrong-here" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="n">string</span><span class="w"> </span><span class="nf">get_name_and_print_sweet_tooth</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">id_number</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Person</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Person</span><span class="p">(</span><span class="n">id_number</span><span class="p">);</span><span class="w"> </span><span class="c1">// assume the constructor fills in variables</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">favorite_food</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;chocolate&quot;</span><span class="w"> </span><span class="o">||</span>
<span class="w">     </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">favorite_drink</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;milkshake&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; has a sweet tooth!&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">();</span>
<span class="w">    </span><span class="k">delete</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="c1">//must release!!!</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="this-problem-isnt-just-unique-to-pointers">This problem isn't just unique to pointers<a class="headerlink" href="#this-problem-isnt-just-unique-to-pointers" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th></th>
<th>Acquire</th>
<th>Release</th>
</tr>
</thead>
<tbody>
<tr>
<td>Heap memory</td>
<td>new</td>
<td>delete</td>
</tr>
<tr>
<td>Files</td>
<td>open</td>
<td>close</td>
</tr>
<tr>
<td>Locks</td>
<td>try_lock</td>
<td>unlock</td>
</tr>
<tr>
<td>Cockets</td>
<td>socket</td>
<td>close</td>
</tr>
</tbody>
</table>
<p>How do we guarantee resources get released, even if there are exceptions?</p>
<h2 id="raii">RAII<a class="headerlink" href="#raii" title="Permanent link">&para;</a></h2>
<blockquote>
<p>Resource Acquisition Is Initialization</p>
</blockquote>
<h3 id="what-is-radouble-i">What is R·A·Double I?<a class="headerlink" href="#what-is-radouble-i" title="Permanent link">&para;</a></h3>
<ul>
<li>All resources used by a class should be acquired in the constructor</li>
<li>All resources used by a class should be released in the destructor</li>
</ul>
<p>Why?</p>
<ul>
<li>Objects should be usable immediately after creation </li>
<li>There should never be a "half-valid" state of an object, where it exists  in memory but is not accessible to/used by the program </li>
<li>The destructor is always called (when the object goes out of scope),  so the resource is always freed</li>
</ul>
<h3 id="is-it-raii-compliant">Is it RAII Compliant?<a class="headerlink" href="#is-it-raii-compliant" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="c1">//The following three algorithms are not RALL</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">printFile</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ifstream</span><span class="w"> </span><span class="n">input</span><span class="p">;</span>
<span class="w">    </span><span class="n">input</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">&quot;hamlet.txt&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">string</span><span class="w"> </span><span class="n">line</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">getline</span><span class="p">(</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// might throw exception</span>
<span class="w">         </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">input</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
<span class="p">}</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">printFile</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ifstream</span><span class="w"> </span><span class="n">input</span><span class="p">(</span><span class="s">&quot;hamlet.txt&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">string</span><span class="w"> </span><span class="n">line</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">getline</span><span class="p">(</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// might throw exception</span>
<span class="w">         </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">cleanDatabase</span><span class="w"> </span><span class="p">(</span><span class="n">mutex</span><span class="o">&amp;</span><span class="w"> </span><span class="n">databaseLock</span><span class="p">,</span><span class="w"> </span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">database</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">databaseLock</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
<span class="w">    </span><span class="c1">// other threads will not modify database</span>
<span class="w">    </span><span class="c1">// modify the database</span>
<span class="w">    </span><span class="c1">// if exception thrown, mutex never unlocked!</span>
<span class="w">    </span><span class="n">databaseLock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>This fixes it!</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">cleanDatabase</span><span class="w"> </span><span class="p">(</span><span class="n">mutex</span><span class="o">&amp;</span><span class="w"> </span><span class="n">databaseLock</span><span class="p">,</span><span class="w"> </span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">database</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lg</span><span class="p">(</span><span class="n">databaseLock</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// other threads will not modify database</span>
<span class="w">    </span><span class="c1">// modify the database</span>
<span class="w">    </span><span class="c1">// if exception thrown, mutex is unlocked!</span>
<span class="w">    </span><span class="c1">// no need to unlock at end, as it&#39;s handle by the lock_guard</span>
<span class="p">}</span>
<span class="k">class</span><span class="w"> </span><span class="nc">lock_guard</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">        </span><span class="n">lock_guard</span><span class="p">(</span><span class="n">mutex</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lock</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">acquired_lock</span><span class="p">(</span><span class="n">lock</span><span class="p">){</span>
<span class="w">            </span><span class="n">acquired_lock</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="o">~</span><span class="n">lock_guard</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">acquired_lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">private</span><span class="o">:</span>
<span class="w">        </span><span class="n">mutex</span><span class="o">&amp;</span><span class="w"> </span><span class="n">acquired_lock</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="what-about-raii-for-memory">What about RAII for memory?<a class="headerlink" href="#what-about-raii-for-memory" title="Permanent link">&para;</a></h3>
<p>This is where we're going with RAII: from the C++ Core Guidelines:</p>
<p><strong>Avoid calling <code>new</code> and <code>delete</code> explicitly</strong></p>
<h2 id="smart-pointers">Smart Pointers<a class="headerlink" href="#smart-pointers" title="Permanent link">&para;</a></h2>
<blockquote>
<p>RAII for memory</p>
</blockquote>
<p>We saw how this was not RAII-compliant because of the "naked" delete.</p>
<div class="highlight"><pre><span></span><code><span class="n">string</span><span class="w"> </span><span class="nf">get_name_and_print_sweet_tooth</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">id_number</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Person</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Person</span><span class="p">(</span><span class="n">id_number</span><span class="p">);</span><span class="w"> </span><span class="c1">//assume the constructor fills in variables</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">favorite_food</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;chocolate&quot;</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">favorite_drink</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;milkshake&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; has a sweet tooth!&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">();</span>
<span class="w">    </span><span class="k">delete</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="solution-built-in-smart-raii-safe-pointers">Solution: built-in "smart" (RAII-safe) pointers<a class="headerlink" href="#solution-built-in-smart-raii-safe-pointers" title="Permanent link">&para;</a></h3>
<ul>
<li>Three types of smart pointers in C++ that automatically free underlying  memory when destructed </li>
<li>std::unique_ptr • Uniquely owns its resource, can't be copied </li>
<li>std::shared_ptr • Can make copies, destructed when underlying memory goes out of  scope </li>
<li>std::weak_ptr • models temporary ownership: when an object only needs to be  accessed if it exists (convert to shared_ptr to access)</li>
</ul>
<h3 id="stdunique_ptr">std::unique_ptr<a class="headerlink" href="#stdunique_ptr" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="c1">//Before</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">rawPtrFn</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Node</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// do things with n</span>
<span class="w">    </span><span class="k">delete</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//After</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">rawPtrFn</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="w"> </span><span class="n">n</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Node</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// do things with n</span>
<span class="w">    </span><span class="c1">// automatically freed!</span>
<span class="p">}</span>
</code></pre></div>
<p>what if we wanted to have multiple  pointers to the same object? <code>std::shared_ptr</code></p>
<h3 id="stdshared_ptr">std::shared_ptr<a class="headerlink" href="#stdshared_ptr" title="Permanent link">&para;</a></h3>
<ul>
<li>Resources can be stored by any number of shared_ptrs</li>
<li>The resource is <strong>deleted</strong> when none of the pointers points to the resource</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p1</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// use p1</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// use p1 and p2</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// use p1, like so</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">p1</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// the integer is now deallocated!</span>
</code></pre></div>
<h3 id="smart-pointers-raii-wrapper-for-pointers">Smart pointers: RAII Wrapper for pointers<a class="headerlink" href="#smart-pointers-raii-wrapper-for-pointers" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">up</span><span class="p">{</span><span class="k">new</span><span class="w"> </span><span class="n">T</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">up</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">sp</span><span class="p">{</span><span class="k">new</span><span class="w"> </span><span class="n">T</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">sp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">wp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sp</span><span class="p">;</span><span class="c1">//A weak_ptr is a container for a raw pointer. It is created as a copy of a shared_ptr. The existence or destruction of weak_ptr copies of a shared_ptr have no effect on the shared_ptr or its other copies. After all copies of a shared_ptr have been destroyed, all weak_ptr copies become empty.</span>
<span class="c1">// can only be copy/move constructed (or empty)!</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="c1">//So which way is better?</span>
<span class="c1">//Always use std::make_unique&lt;T&gt;()!</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">up</span><span class="p">{</span><span class="k">new</span><span class="w"> </span><span class="n">T</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">up</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">sp</span><span class="p">{</span><span class="k">new</span><span class="w"> </span><span class="n">T</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">sp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span>
</code></pre></div>
<ul>
<li>If we don't use make_shared, then we're allocating memory twice (once for sp, and once for new T)!</li>
<li>We should be consistent across smart pointers</li>
</ul>
<h2 id="building-c-projects">Building C++ Projects<a class="headerlink" href="#building-c-projects" title="Permanent link">&para;</a></h2>
<blockquote>
<p>What happens when you run our "./build_and_run.sh"?</p>
</blockquote>
<h3 id="what-do-make-and-makefiles-do">What do make and Makefiles do?<a class="headerlink" href="#what-do-make-and-makefiles-do" title="Permanent link">&para;</a></h3>
<ul>
<li>make is a "build system" </li>
<li>uses g++ as its main engine</li>
<li>several stages to the compiler system</li>
<li>can be utilized through a Makefile!</li>
<li>let's take a look at a simple makefile to get some practice!</li>
</ul>
<h3 id="so-why-do-we-use-cmake-in-our-assignments">So why do we use cmake in our assignments?<a class="headerlink" href="#so-why-do-we-use-cmake-in-our-assignments" title="Permanent link">&para;</a></h3>
<ul>
<li>cmake is a cross-platform make</li>
<li>cmake creates build systems!</li>
<li>It takes in an even higher-level config file, ties in external libraries,  and outputs a Makefile, which is then run. </li>
<li>Let's take a look at our makefiles!</li>
</ul>
<h3 id="example-cmake-file-cmakeliststxt">Example cmake file (CMakeLists.txt)<a class="headerlink" href="#example-cmake-file-cmakeliststxt" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>cmake_minimum_required<span class="o">(</span>VERSION<span class="w"> </span><span class="m">3</span>.0<span class="o">)</span><span class="w"> </span><span class="c1"># 指定 cmake 最低版本</span>
project<span class="o">(</span>wikiracer<span class="o">)</span><span class="w"> </span><span class="c1"># 指定项目名称(随意)</span>
set<span class="o">(</span>CMAKE_CXX_STANDARD<span class="w"> </span><span class="m">17</span><span class="o">)</span><span class="w"> </span>
set<span class="o">(</span>CMAKE_CXX_STANDARD_REQUIRED<span class="w"> </span>True<span class="o">)</span><span class="w"> </span>
find_package<span class="o">(</span>cpr<span class="w"> </span>CONFIG<span class="w"> </span>REQUIRED<span class="o">)</span><span class="w"> </span>
<span class="c1"># adding all files </span>
add_executable<span class="o">(</span>main<span class="w"> </span>main.cpp<span class="w"> </span>wikiscraper.cpp.o<span class="w"> </span>error.cpp<span class="o">)</span><span class="w"> </span><span class="c1"># 指定编译一个可执行文件，main是第一个参数，表示生成可执行文件的文件名（这个文件名也是任意的），第二个参数main.cpp则用于指定源文件。</span>
target_link_libraries<span class="o">(</span>main<span class="w"> </span>PRIVATE<span class="w"> </span>cpr<span class="o">)</span>
</code></pre></div>
<h3 id="components-of-cs-compilation-system">Components of C++'s compilation system<a class="headerlink" href="#components-of-cs-compilation-system" title="Permanent link">&para;</a></h3>
<pre class="mermaid"><code>graph LR
A[Preprocessing &lt;br&gt;in: cpp files out: full cpp files]--&gt;B[Compiling &lt;br&gt;in: full cpp files out: .s files]--&gt;C[Assembling &lt;br&gt;in: .s files out: .o files]--&gt;D[Linking&lt;br&gt; in: .o files out: executable]</code></pre>
<h3 id="preprocessing-g--e">Preprocessing (g++ -E)<a class="headerlink" href="#preprocessing-g--e" title="Permanent link">&para;</a></h3>
<ul>
<li>The C/C++ preprocessor handles preprocessor directives: replaces  includes (#include …) and and expands any macros (#define …) </li>
<li>Replace #includes with content of respective files (which is  usually just function/variable declarations, so low bloat)</li>
<li>Replaces macros (#define) and selecting different portions of text  depending on #if, #ifdef, #ifndef </li>
<li>Outputs a stream of tokens resulting from these transformations</li>
<li>If you want, you can produce some errors at even this stage (#if,  #error)</li>
</ul>
<h3 id="compilation-g--s">Compilation (g++ -S)<a class="headerlink" href="#compilation-g--s" title="Permanent link">&para;</a></h3>
<ul>
<li>Performed on output of the preprocessor (full C++ code)</li>
<li>Structure of a compiler: </li>
<li>Lexical Analysis</li>
<li>Parsing </li>
<li>Semantic Analysis</li>
<li>Optimization</li>
<li>Code Generation (assembly code) </li>
<li>This is where traditional "compiler errors" are caught</li>
</ul>
<h3 id="assembling-g--c">Assembling (g++ -c)<a class="headerlink" href="#assembling-g--c" title="Permanent link">&para;</a></h3>
<ul>
<li>Runs on the assembly code as outputted by the compiler</li>
<li>Converts assembly code to binary machine code</li>
<li>Assumes that all functions are defined somewhere without checking</li>
<li>Final output: object files</li>
<li>Can't be run by themselves!</li>
</ul>
<h3 id="linking-ld-g">Linking (ld, g++)<a class="headerlink" href="#linking-ld-g" title="Permanent link">&para;</a></h3>
<ul>
<li>Creates a single executable file from multiple object files </li>
<li>Combine the pieces of a program</li>
<li>Figure out a memory organization so that all the pieces can fit  together </li>
<li>Resolve references so that the program can run under the new  memory organization<ul>
<li>.h files declare functions, but the actual functions may be in  separate files from where they're called!</li>
</ul>
</li>
<li>Output is fully self-suficient—no other files needed to run</li>
</ul>







  
  






                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      本页面的全部内容在 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh">CC BY-SA 4.0</a> 和 <a href="https://github.com/zTrix/sata-license">SATA</a> 协议之条款下提供，附加条款亦可能应用。
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../../..", "features": ["navigation.tabs", "content.code.annotate", "navigation.tracking", "navigation.indexes", "navigation.top", "toc.follow"], "search": "../../../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.a7c05c9e.min.js"></script>
      
        <script src="../../../from_oi_wiki/js/extra.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
      
    
  </body>
</html>